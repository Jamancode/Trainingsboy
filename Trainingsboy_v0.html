<!DOCTYPE html>
<html lang="de" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üèãÔ∏è Ultimate Fitness Tracker - Vollst√§ndige Implementierung v3.0</title>
    <!-- Chart.js und der Date-Adapter werden f√ºr die Analyse-Diagramme per CDN geladen -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

    <style>
        /* =================================================================== */
        /*  CSS STYLING - wie vom Benutzer bereitgestellt, mit kleinen Anpassungen */
        /* =================================================================== */

        /* CSS Variables f√ºr Theming */
        :root {
            --primary: #2563eb; --primary-dark: #1d4ed8; --secondary: #10b981; --danger: #ef4444;
            --warning: #f59e0b; --surface-bg: #f3f4f6; --surface-card: white; --text-primary: #111827;
            --text-secondary: #6b7280; --border: #e5e7eb; --shadow: 0 1px 3px rgba(0,0,0,0.07);
            --shadow-lg: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
            --radius: 0.75rem; --transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        }
        [data-theme="dark"] {
            --primary: #3b82f6; --primary-dark: #2563eb; --secondary: #34d399; --surface-bg: #0f172a;
            --surface-card: #1e293b; --text-primary: #e2e8f0; --text-secondary: #94a3b8; --border: #334155;
        }

        /* Globale Stile & Resets */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background: var(--surface-bg); color: var(--text-primary); line-height: 1.6; transition: background 0.3s, color 0.3s; }
        
        /* Layout-Komponenten */
        .app-container { min-height: 100vh; display: flex; flex-direction: column; }
        .header { background: color-mix(in srgb, var(--surface-card) 85%, transparent); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-bottom: 1px solid var(--border); padding: 1rem 2rem; position: sticky; top: 0; z-index: 1000; }
        .header-content { max-width: 1400px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; }
        .main-content { flex: 1; padding: 2rem; max-width: 1400px; margin: 0 auto; width: 100%; }
        .section { display: none; animation: fadeIn 0.5s ease-out; }
        .section.active { display: block; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 1.5rem; }
        
        /* Typografie */
        h1, h2, h3 { color: var(--text-primary); margin-bottom: 0.5rem; letter-spacing: -0.02em; }
        h1 { font-size: 2.5rem; font-weight: 800; }
        h2 { font-size: 1.8rem; border-bottom: 1px solid var(--border); padding-bottom: 0.75rem; margin-top: 2.5rem; margin-bottom: 1.5rem; font-weight: 700; }
        h3 { font-size: 1.25rem; font-weight: 600; }
        p { margin-bottom: 1.25rem; color: var(--text-secondary); max-width: 70ch; }
        
        /* UI-Komponenten */
        .logo { font-size: 1.5rem; font-weight: 700; display: flex; align-items: center; gap: 0.75rem; }
        .nav-tabs { display: flex; gap: 0.5rem; background: var(--surface-bg); padding: 0.25rem; border-radius: var(--radius); border: 1px solid var(--border); }
        .nav-tab { padding: 0.5rem 1rem; background: transparent; border: none; color: var(--text-secondary); cursor: pointer; border-radius: 0.6rem; transition: var(--transition); font-weight: 600; font-size: 0.9rem; }
        .nav-tab.active, .nav-tab:hover { background: var(--primary); color: white; box-shadow: var(--shadow); }
        .theme-toggle { background: var(--surface); border: 1px solid var(--border); color: var(--text-primary); cursor: pointer; font-size: 1.1rem; width: 44px; height: 44px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: var(--transition); }
        .theme-toggle:hover { transform: rotate(15deg) scale(1.1); box-shadow: var(--shadow-lg); }
        .card, .stat-card, .mode-card, .suggestion-card { background: var(--surface-card); padding: 1.5rem; border-radius: var(--radius); box-shadow: var(--shadow); border: 1px solid var(--border); transition: var(--transition); }
        .card:hover, .stat-card:hover, .mode-card:hover { transform: translateY(-5px); box-shadow: var(--shadow-lg); }
        .stat-value { font-size: 2.5rem; font-weight: 700; color: var(--primary); line-height: 1.1; }
        .stat-label { color: var(--text-secondary); font-size: 0.9rem; }
        .btn { padding: 0.75rem 1.5rem; border: none; border-radius: 0.5rem; font-size: 1rem; font-weight: 600; cursor: pointer; transition: var(--transition); display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem; text-decoration: none; }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-dark); transform: translateY(-2px); box-shadow: var(--shadow); }
        .btn-secondary { background: var(--secondary); color: white; }
        .btn-danger { background: var(--danger); color: white; }
        button:disabled { background-color: var(--text-secondary); cursor: not-allowed; opacity: 0.7; }

        /* Formulare */
        .form-group { margin-bottom: 1.5rem; }
        label { display: block; margin-bottom: 0.5rem; font-weight: 500; }
        input, select, textarea { width: 100%; padding: 0.85rem; border: 1px solid var(--border); border-radius: 0.5rem; background: var(--surface-bg); color: var(--text-primary); font-size: 1rem; transition: var(--transition); }
        input:focus, select:focus, textarea:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary) 20%, transparent); }
        .input-group { display: flex; align-items: center; }
        .input-group input { border-radius: 0.5rem 0 0 0.5rem; }
        .input-group-text { padding: 0.85rem; background: var(--border); border: 1px solid var(--border); border-left: none; border-radius: 0 0.5rem 0.5rem 0;}

        /* Modals */
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); z-index: 2000; justify-content: center; align-items: center; backdrop-filter: blur(5px); }
        .modal.active { display: flex; animation: fadeIn 0.3s; }
        .modal-content { background: var(--surface-card); border-radius: var(--radius); padding: 2.5rem; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto; animation: slideIn 0.3s ease-out; border: 1px solid var(--border); }
        @keyframes slideIn { from { transform: translateY(-30px) scale(0.98); opacity: 0; } to { transform: translateY(0) scale(1); opacity: 1; } }
        
        /* Drag & Drop */
        .exercise-item { padding: 1rem; border: 1px solid var(--border); border-radius: var(--radius); margin-bottom: 0.5rem; cursor: grab; transition: var(--transition); display: flex; justify-content: space-between; align-items: center; background: var(--surface-bg); }
        .exercise-item:hover { background-color: var(--primary); color: white; transform: translateX(4px); }
        .exercise-item.dragging { opacity: 0.4; transform: scale(1.05); box-shadow: var(--shadow-lg); }
        .drop-zone { min-height: 200px; border: 2px dashed var(--border); border-radius: var(--radius); padding: 1rem; text-align: center; color: var(--text-secondary); transition: var(--transition); }
        .drop-zone.drag-over { background: color-mix(in srgb, var(--primary) 10%, transparent); border-color: var(--primary); }

        /* Spezifische Komponenten-Stile */
        .mode-card { text-align: center; cursor: pointer; border: 2px solid var(--border); }
        .mode-card.selected { border-color: var(--primary); box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary) 40%, transparent); }
        .mode-icon { font-size: 3rem; margin-bottom: 1rem; filter: grayscale(50%); transition: var(--transition); }
        .mode-card.selected .mode-icon { filter: grayscale(0%); transform: scale(1.1); }
        .suggestion-card { background: linear-gradient(135deg, var(--warning), #d97706); color: white; display: flex; align-items: center; gap: 1rem; }
        .suggestion-icon { font-size: 2rem; }
        .hydration-tracker { display: flex; gap: 0.5rem; align-items: center; padding: 1rem; background: linear-gradient(135deg, #3b82f6, #60a5fa); border-radius: var(--radius); color: white; flex-wrap: wrap;}
        .water-glass { width: 30px; height: 40px; border: 2px solid white; border-radius: 0 0 5px 5px; position: relative; cursor: pointer; transition: var(--transition); }
        .water-glass .water-fill { position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(255, 255, 255, 0.7); transition: height 0.3s; }
        .intensity-meter { display: flex; gap: 0.35rem; align-items: center; padding: 0.5rem; height: 50px; }
        .intensity-bar { width: 20px; height: 100%; background: var(--border); border-radius: 2px; transition: var(--transition); transform-origin: bottom; }
        .heatmap-container { display: grid; grid-template-columns: repeat(26, 1fr); gap: 4px; }
        .heatmap-cell { aspect-ratio: 1; background-color: var(--border); border-radius: 2px; transition: var(--transition); cursor: pointer; }
        .heatmap-cell:hover { transform: scale(1.2); z-index: 10; position: relative; }
        .heatmap-cell[data-intensity='1'] { background-color: color-mix(in srgb, var(--secondary) 25%, var(--surface-bg)); }
        .heatmap-cell[data-intensity='2'] { background-color: color-mix(in srgb, var(--secondary) 60%, var(--surface-bg)); }
        .heatmap-cell[data-intensity='3'] { background-color: var(--secondary); }
        .muscle-map { display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 1rem; }
        .muscle-group { padding: 1rem; text-align: center; border: 2px solid var(--border); border-radius: var(--radius); transition: var(--transition); opacity: 0.6; }
        .muscle-group.worked { opacity: 1; background: color-mix(in srgb, var(--secondary) 20%, transparent); font-weight: 600; }
        .achievement { display: flex; align-items: center; gap: 1rem; padding: 1rem; background: linear-gradient(135deg, gold, darkorange); color: #333; border-radius: var(--radius); margin-bottom: 1rem; box-shadow: var(--shadow-lg); }
        .achievement-icon { font-size: 2rem; }
        .rest-timer-widget { position: fixed; bottom: 2rem; right: 2rem; background: var(--surface-card); padding: 1.5rem; border-radius: var(--radius); box-shadow: var(--shadow-lg); z-index: 1001; display: none; border: 1px solid var(--border); text-align: center; }
        .rest-timer-widget.active { display: block; animation: slideInUp 0.3s ease-out; }
        .breathing-circle { width: 150px; height: 150px; margin: 2rem auto; background: var(--primary); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; transition: transform 4s ease-in-out; }
        #notification-container { position: fixed; bottom: 1rem; right: 1rem; z-index: 3000; display: flex; flex-direction: column; gap: 0.75rem; }
        .toast { padding: 1rem 1.5rem; border-radius: 0.5rem; color: white; box-shadow: var(--shadow-lg); animation: toastIn 0.5s cubic-bezier(0.25, 1, 0.5, 1); min-width: 320px; display: flex; align-items: center; gap: 1rem; }
        .toast-icon { font-size: 1.5rem; }
        .toast.success { background: linear-gradient(135deg, var(--secondary), #059669); }
        .toast.error { background: linear-gradient(135deg, var(--danger), #dc2626); }
        .toast.info { background: linear-gradient(135deg, var(--primary), var(--primary-dark)); }
        
        /* Animation Keyframes */
        @keyframes fadeIn { from { opacity: 0; transform: translateY(15px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes slideInUp { from { transform: translateY(100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes toastIn { from { transform: translateX(120%); } to { transform: translateX(0); } }

        /* Responsive Design */
        @media (max-width: 768px) { .exercise-container, .mode-selector { grid-template-columns: 1fr; } .header-content { flex-direction: column; gap: 1rem; } .nav-tabs { flex-wrap: wrap; justify-content: center; } }
    </style>
</head>
<body>
    <div id="notification-container"></div>
    <div class="app-container">
        <!-- HEADER -->
        <header class="header">
            <div class="header-content">
                <div class="logo">üí™ UFT</div>
                <nav class="nav-tabs" id="main-nav"></nav>
                <button id="themeToggle" class="theme-toggle" aria-label="Toggle Theme">üåô</button>
            </div>
        </header>

        <!-- MAIN CONTENT -->
        <main class="main-content" id="main-content-container">
            <!-- Views will be dynamically rendered here -->
        </main>
    </div>

    <!-- MODALS & WIDGETS -->
    <div class="modal" id="formModal"><div class="modal-content" id="formModalContent"></div></div>
    <div class="modal" id="planEditorModal"><div class="modal-content" id="planEditorModalContent" style="max-width: 1200px;"></div></div>
    <div class="modal" id="workoutCompleteModal"><div class="modal-content" id="workoutCompleteModalContent"></div></div>
    <div class="modal" id="breathingModal">
        <div class="modal-content">
            <h2>Fokus-Atmung</h2>
            <p>Ein kurzer Moment der Konzentration vor dem n√§chsten schweren Satz.</p>
            <div class="breathing-circle" id="breathing-circle"><span id="breathingText">Start...</span></div>
            <button class="btn btn-primary" data-action="close-modal" data-modal-id="breathingModal">Fertig</button>
        </div>
    </div>
    <div class="rest-timer-widget" id="restTimerWidget">
        <h3>Pause</h3>
        <div class="timer" id="widgetTimer">00:00</div>
        <button class="btn btn-danger" data-action="skip-rest">√úberspringen</button>
    </div>

    <script>
    // ===================================================================
    //  üèãÔ∏è ULTIMATE FITNESS TRACKER - COMPLETE IMPLEMENTATION v3.1
    // ===================================================================
    //  Author: KI-Modell, basierend auf der Analyse des Benutzers
    //  Version: 3.1 (Comprehensive, Reactive, IndexedDB)
    //  Line Count Target: >3000
    // ===================================================================

    const App = {
        // Centralized application state, loaded asynchronously
        state: {}, 
        // Chart instances to prevent memory leaks
        charts: {},
        // Global timers
        timers: { rest: null, breath: null, autosave: null },

        // ===================================================================
        // 1. CORE APP LIFECYCLE & INITIALIZATION
        // ===================================================================

        /**
         * Initializes the application. This is the main entry point.
         * It establishes a database connection, loads data, initializes UI components,
         * attaches event listeners, and performs the first render.
         */
        async init() {
            try {
                // Establish DB connection first
                await this.db.init();
                // Load state from DB
                this.state = await this.storage.load();
                
                this.ui.init();
                this.addEventListeners();
                this.render();

                // Start the autosave interval
                this.timers.autosave = setInterval(() => this.storage.save(this.state), 30000); // Autosave every 30 seconds
                console.log("Ultimate Fitness Tracker Initialized. State:", this.state);
            } catch (error) {
                console.error("Critical error during app initialization:", error);
                document.body.innerHTML = `<h1>Ein kritischer Fehler ist aufgetreten.</h1><p>Die App konnte nicht gestartet werden. Bitte versuchen Sie, die Anwendungsdaten in Ihrem Browser zu l√∂schen oder kontaktieren Sie den Support. Fehler: ${error.message}</p>`;
            }
        },

        /**
         * The master render function. It orchestrates all UI updates based on the current app state.
         * This function ensures the UI is always a reflection of the data.
         */
        render() {
            this.ui.renderTheme();
            this.ui.renderNav();
            
            // Route to the correct view renderer
            const viewContainer = document.getElementById('main-content-container');
            switch(this.state.ui.currentView) {
                case 'dashboard': viewContainer.innerHTML = this.ui.renderDashboard(); break;
                case 'plans': viewContainer.innerHTML = this.ui.renderPlans(); break;
                case 'training': viewContainer.innerHTML = this.ui.renderTraining(); break;
                case 'exercises': viewContainer.innerHTML = this.ui.renderExercises(); break;
                case 'analytics': 
                    viewContainer.innerHTML = this.ui.renderAnalyticsShell();
                    // Charts need to be rendered after the shell is in the DOM
                    setTimeout(() => this.ui.renderAnalyticsCharts(), 0);
                    break;
                case 'settings': viewContainer.innerHTML = this.ui.renderSettings(); break;
            }
        },

        /**
         * Attaches global, persistent event listeners using event delegation.
         */
        addEventListeners() {
            const body = document.body;

            // Main navigation and theme toggle
            document.getElementById('main-nav').addEventListener('click', e => {
                if (e.target.matches('[data-action="navigate"]')) {
                    this.state.ui.currentView = e.target.dataset.view;
                    this.render();
                }
            });
            document.getElementById('themeToggle').addEventListener('click', () => {
                this.state.ui.theme = this.state.ui.theme === 'light' ? 'dark' : 'light';
                this.render();
            });
            
            // Global click handler for actions
            body.addEventListener('click', e => {
                const actionTarget = e.target.closest('[data-action]');
                if (!actionTarget) return;

                const { action, ...data } = actionTarget.dataset;
                
                // A simple router for actions
                switch(action) {
                    case 'navigate':
                        this.state.ui.currentView = data.view;
                        this.render();
                        break;
                    case 'set-user-level':
                        this.logic.user.setLevel(data.level, this.state);
                        this.storage.save(this.state);
                        this.render();
                        break;
                    case 'update-hydration':
                        this.logic.user.updateHydration(parseInt(data.amount), this.state);
                        this.storage.save(this.state);
                        this.render();
                        break;
                    case 'show-exercise-form': this.ui.showExerciseForm(); break;
                    case 'show-plan-form': this.ui.showPlanForm(); break;
                    case 'show-equipment-form': this.ui.showEquipmentForm(); break;
                    case 'edit-equipment': // Added case for editing equipment
                        const equipmentToEdit = this.state.equipment.get(data.id);
                        if (equipmentToEdit) {
                            this.ui.showEquipmentForm(equipmentToEdit);
                        } else {
                            this.ui.showToast('‚ùå', 'Ger√§t nicht gefunden!', 'error');
                        }
                        break;
                    case 'delete-equipment': // Added case for deleting equipment
                        if (confirm('Sind Sie sicher, dass Sie dieses Ger√§t l√∂schen m√∂chten? Diese Aktion kann nicht r√ºckg√§ngig gemacht werden.')) {
                            (async () => {
                                await this.logic.equipmentManager.deleteItem(data.id, this.state);
                                this.ui.showToast('‚úÖ', 'Ger√§t gel√∂scht!', 'success');
                                this.render(); // Re-render current view
                            })();
                        }
                        break;
                    case 'show-plan-editor': this.ui.showPlanEditor(data.planId); break;
                    case 'remove-exercise-from-plan': 
                        this.logic.plans.removeExercise(data.planId, data.exId, this.state);
                        this.ui.renderPlanEditorContent(data.planId);
                        break;
                    case 'start-session': this.logic.session.start(data.planId); break;
                    case 'start-quick-set': this.logic.session.startQuickSet(); break;
                    case 'perform-set': this.ui.handleSetCompletion(actionTarget); break; // Confirmed
                    case 'next-exercise': this.logic.session.nextExercise(this.state); break;
                    case 'finish-session': this.logic.session.finishSession(this.state); break;
                    case 'skip-rest': this.logic.session.skipRest(); break; // Confirmed logic call
                    case 'save-settings': this.saveSettings(); break;
                    case 'export-data': this.storage.export(); break;
                    case 'import-data': document.getElementById('importFileInput').click(); break;
                    case 'reset-data': this.resetData(); break;
                    case 'close-modal': this.ui.closeModal(data.modalId); break;
                }
            });

            // Global form submission handler
            body.addEventListener('submit', e => {
                const form = e.target;
                if (form.matches('[data-form]')) {
                    e.preventDefault();
                    const formData = new FormData(form);
                    const data = Object.fromEntries(formData.entries());
                    
                    switch(form.dataset.form) {
                        case 'add-exercise':
                            this.logic.exercises.create(data, this.state);
                            this.ui.closeModal('formModal');
                            this.ui.showToast('‚úÖ', '√úbung erstellt!', 'success');
                            this.render();
                            break;
                        case 'add-plan':
                            const plan = this.logic.plans.create(data, this.state);
                            this.ui.closeModal('formModal');
                            this.ui.showPlanEditor(plan.id); // Navigate to editor after creation
                            this.render(); // Re-render current view (likely 'plans')
                            break;
                        case 'add-exercise-set':
                            // formData.getAll('exerciseIds') will return an array of values from checked checkboxes
                            const exerciseIdsArray = formData.getAll('exerciseIds');
                            this.logic.exerciseSetManager.create(data.name, exerciseIdsArray, this.state);
                            this.ui.closeModal('formModal');
                            this.ui.showToast('‚úÖ', '√úbungsset erstellt!', 'success');
                            if (this.state.ui.currentView === 'exercises') { // Re-render if on exercises page
                                this.render();
                            }
                            break;
                        case 'equipment-form': // Added case for equipment form
                            (async () => { // Use async IIFE to handle await
                                if (data.equipmentId) { // Edit mode
                                    await this.logic.equipmentManager.update(data.equipmentId, data.name, data.description, this.state);
                                    this.ui.showToast('‚úÖ', 'Ger√§t aktualisiert!', 'success');
                                } else { // Create mode
                                    await this.logic.equipmentManager.create(data.name, data.description, this.state);
                                    this.ui.showToast('‚úÖ', 'Ger√§t erstellt!', 'success');
                                }
                                this.ui.closeModal('formModal');
                                this.render(); // Re-render current view (likely settings)
                            })();
                            break;
                    }
                }
            });

            // Global input change handler (for live updates in plan editor)
            body.addEventListener('change', e => {
                const input = e.target;
                if (input.matches('[data-update-plan-ex]')) {
                    const { planId, exId, field } = input.dataset;
                    this.logic.plans.updateExerciseInPlan(planId, exId, field, input.value, this.state);
                } else if (input.matches('[data-update-plan-meta]')) {
                    const { planId } = input.dataset;
                    const fieldName = input.name === 'planEditorName' ? 'name' : 'description';
                    const plan = this.state.plans.get(planId);
                    if (plan) {
                        plan[fieldName] = input.value;
                        plan.lastModified = Date.now();
                        App.db.put('plans', plan).then(() => {
                            App.ui.showToast("üí°", "Plandetails aktualisiert.", "info");
                            if (fieldName === 'name' && document.getElementById('planEditorModal').classList.contains('active')) {
                                // Update the header H2 if the input is not directly the H2 content
                                const headerH2 = document.querySelector('#planEditorModalContent > div > h2');
                                if (headerH2 && !headerH2.querySelector('input')) { // Only if H2 is static text
                                   headerH2.textContent = `Plan bearbeiten: ${input.value}`;
                                } else if (headerH2 && headerH2.firstChild.nodeType === Node.TEXT_NODE) { // If H2 has text like "Plan: <input>"
                                   headerH2.firstChild.textContent = `Plan: `; // Keep prefix, input value updates itself
                                }
                            }
                            if(this.state.ui.currentView === 'plans') this.render();
                        }).catch(err => {
                            console.error("Failed to update plan meta:", err);
                            App.ui.showToast("‚ùå", "Fehler beim Speichern der Plandetails.", "error");
                        });
                    }
                }
            });

             // Global Drag and Drop handlers
            let draggedElementId = null;
            body.addEventListener('dragstart', e => {
                const target = e.target.closest('[data-drag-id]');
                if (target) {
                    draggedElementId = target.dataset.dragId;
                    setTimeout(() => target.classList.add('dragging'), 0);
                }
            });
            body.addEventListener('dragend', e => {
                const target = e.target.closest('[data-drag-id]');
                if (target) target.classList.remove('dragging');
                draggedElementId = null;
            });
            body.addEventListener('dragover', e => {
                if (e.target.closest('.drop-zone')) e.preventDefault();
            });
            body.addEventListener('drop', e => {
                const dropZone = e.target.closest('.drop-zone');
                if (!dropZone || !draggedElementId) return;
                e.preventDefault();
                const { dropAction, ...data } = dropZone.dataset;
                
                if (dropAction === "add-to-quick-set") {
                    this.logic.session.addToQuickSet(draggedElementId, this.state);
                    // App.render() is called within addToQuickSet if UI needs update
                } else if (dropAction === "add-to-plan") {
                    // Ensure this is async to await the logic and then re-render
                    (async () => {
                        await this.logic.plans.addExerciseToPlan(data.planId, draggedElementId, {}, this.state);
                        this.ui.renderPlanEditorContent(data.planId); // Refresh editor content
                    })();
                }
            });

            // Handle file input for import
            const importInput = document.createElement('input');
            importInput.type = 'file';
            importInput.id = 'importFileInput';
            importInput.style.display = 'none';
            importInput.accept = '.json';
            importInput.addEventListener('change', e => this.storage.import(e));
            document.body.appendChild(importInput);
            
            // Save state before the user leaves the page
            window.addEventListener('beforeunload', () => this.storage.save(this.state));
        },

        // ===================================================================
        // 2. DATABASE (IndexedDB) & STORAGE MANAGEMENT
        // ===================================================================

        db: {
            DB_NAME: 'UFT_DB',
            DB_VERSION: 4,
            db: null,

            init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);
                    request.onerror = event => reject(`IndexedDB error: ${event.target.errorCode}`);
                    request.onsuccess = event => {
                        this.db = event.target.result;
                        resolve(this.db);
                    };
                    request.onupgradeneeded = event => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('settings')) db.createObjectStore('settings', { keyPath: 'id' });
                        if (!db.objectStoreNames.contains('exercises')) db.createObjectStore('exercises', { keyPath: 'id' });
                        if (!db.objectStoreNames.contains('plans')) db.createObjectStore('plans', { keyPath: 'id' });
                        if (!db.objectStoreNames.contains('history')) db.createObjectStore('history', { keyPath: 'startTime' });
                        if (!db.objectStoreNames.contains('exerciseSets')) db.createObjectStore('exerciseSets', { keyPath: 'id' }); // 1. DB Schema Update
                        if (!db.objectStoreNames.contains('equipment')) db.createObjectStore('equipment', { keyPath: 'id' });
                    };
                });
            },
            
            get(storeName, key) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(storeName, 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.get(key);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = event => reject(event.target.error);
                });
            },

            getAll(storeName) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(storeName, 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = event => reject(event.target.error);
                });
            },
            
            put(storeName, data) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(storeName, 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put(data);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = event => reject(event.target.error);
                    transaction.oncomplete = () => resolve();
                });
            },
            
            clear(storeName) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(storeName, 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.clear();
                    request.onsuccess = () => resolve();
                    request.onerror = event => reject(event.target.error);
                });
            },

            delete(storeName, key) { // 7. Implement App.db.delete
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(storeName, 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.delete(key);
                    request.onsuccess = () => resolve(); // Typically, delete doesn't return the object
                    request.onerror = event => reject(event.target.error);
                    // transaction.oncomplete might be redundant if request.onsuccess is sufficient
                });
            }
        },

        storage: {
            /**
             * Loads the application state from IndexedDB.
             * @returns {Promise<object>} A promise that resolves with the application state.
             */
            async load() {
                const [settings, exercises, plans, history, exerciseSetsData, equipmentData] = await Promise.all([ // 4. Storage Load
                    App.db.getAll('settings'),
                    App.db.getAll('exercises'),
                    App.db.getAll('plans'),
                    App.db.getAll('history'),
                    App.db.getAll('exerciseSets'), // Load exercise sets
                    App.db.getAll('equipment') // Fetch equipment data
                ]);

                if (settings.length === 0) {
                    return this.getInitialStateAndPersist();
                }

                const state = settings[0]; // Settings store holds the main state object
                state.exercises = new Map(exercises.map(e => [e.id, e]));
                state.plans = new Map(plans.map(p => [p.id, p]));
                state.exerciseSets = new Map(exerciseSetsData.map(s => [s.id, s])); // Reconstruct Map
                state.equipment = new Map(equipmentData.map(item => [item.id, item])); // Reconstruct Map for equipment
                state.history = history;
                state.achievements = new Set(state.achievements || []);

                // Initialize parts of state if they are missing (backward compatibility)
                if (!state.user) state.user = { name: 'Athlet', level: 'intermediate', hydration: { goal: 8, current: 0 } };
                if (!state.exercises) state.exercises = new Map();
                if (!state.plans) state.plans = new Map();
                // history is already assigned
                // achievements is already assigned and ensured to be a Set
                if (!state.quickSet) state.quickSet = [];
                if (!state.exerciseSets) state.exerciseSets = new Map();
                if (!state.equipment) state.equipment = new Map(); // Added for equipment
                if (!state.trainingMetrics) {
                    state.trainingMetrics = { volumeLoad: 0, intensityIndex: 0, fatigueLevel: 0, recoveryScore: 100, performanceIndex: 100 };
                }
                if (!state.ui) state.ui = { currentView: 'dashboard', theme: 'dark' };


                return state;
            },

            /**
             * Saves the current application state to IndexedDB.
             * @param {object} state - The current application state.
             */
            async save(state) {
                if (!state || Object.keys(state).length === 0) return;
                try {
                    // Create a storable copy of the main state object
                    const settingsToSave = { ...state, id: 'app_state' };
                    delete settingsToSave.exercises;
                    delete settingsToSave.plans;
                    delete settingsToSave.history;
                    delete settingsToSave.exerciseSets; // Ensure exerciseSets Map is not saved in settings object
                    delete settingsToSave.equipment; // Ensure equipment Map is not saved in settings object
                    settingsToSave.achievements = Array.from(settingsToSave.achievements || []);

                    // Use Promise.all to save everything concurrently
                    await Promise.all([
                        App.db.put('settings', settingsToSave),
                        ...Array.from(state.exercises.values()).map(ex => App.db.put('exercises', ex)),
                        ...Array.from(state.plans.values()).map(p => App.db.put('plans', p)),
                        ...Array.from(state.exerciseSets.values()).map(set => App.db.put('exerciseSets', set)), // 3. Storage Save
                        ...Array.from(state.equipment.values()).map(item => App.db.put('equipment', item)),
                        // History is only added to, not re-saved in its entirety
                    ]);
                } catch (e) {
                    console.error("Error saving state to IndexedDB:", e);
                }
            },

            /**
             * Creates and PERSISTS the default initial state for a new user.
             * @returns {Promise<object>} The initial application state.
             */
            async getInitialStateAndPersist() {
                App.ui.showToast("Willkommen! Beispieldaten werden f√ºr dich geladen.", "info");
                const initialState = {
                    user: { name: 'Athlet', level: 'intermediate', hydration: { goal: 8, current: 0 } },
                    exercises: new Map(),
                    plans: new Map(),
                    history: [],
                    achievements: new Set(),
                    quickSet: [],
                    exerciseSets: new Map(), // 2. State Initialization
                    equipment: new Map(),
                    trainingMetrics: { volumeLoad: 0, intensityIndex: 0, fatigueLevel: 0, recoveryScore: 100, performanceIndex: 100 },
                    ui: { currentView: 'dashboard', theme: 'dark' },
                };

                // Add sample exercises and plans to the state object
                const ex1 = App.logic.exercises.create({ name: "Bankdr√ºcken", muscleGroup: "chest", type: "compound" }, initialState);
                const ex2 = App.logic.exercises.create({ name: "Kniebeugen", muscleGroup: "legs", type: "compound" }, initialState);
                const ex3 = App.logic.exercises.create({ name: "Latzug", muscleGroup: "back", type: "compound" }, initialState);
                const ex4 = App.logic.exercises.create({ name: "Seitheben", muscleGroup: "shoulders", type: "isolation" }, initialState);
                App.logic.plans.create({
                    name: "Ganzk√∂rper A", description: "Ein solides Workout f√ºr den ganzen K√∂rper.",
                    exercises: [
                        { id: ex2.id, sets: 3, reps: "5-8", rest: 120 },
                        { id: ex1.id, sets: 3, reps: "5-8", rest: 120 },
                        { id: ex3.id, sets: 3, reps: "8-12", rest: 90 },
                    ]
                }, initialState);
                
                // Persist this initial state to the database
                await this.save(initialState);
                return initialState;
            },
            
            async export() {
                try {
                    const state = await this.load(); // Load the full current state
                     // De-hydrate for export
                    state.exercises = Array.from(state.exercises.entries());
                    state.plans = Array.from(state.plans.entries());
                    state.achievements = Array.from(state.achievements);
                    const data = JSON.stringify(state, null, 2);
                    const blob = new Blob([data], {type: 'application/json'});
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = `uft-backup-${new Date().toISOString().slice(0,10)}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(a.href);
                    App.ui.showToast("Daten erfolgreich exportiert!", "success");
                } catch (e) {
                    App.ui.showToast("Export fehlgeschlagen!", "error");
                    console.error(e);
                }
            },
            
            import(event) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async e => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if(data.user && Array.isArray(data.exercises) && Array.isArray(data.plans)) {
                            // Clear existing DB
                            await Promise.all([
                                App.db.clear('settings'),
                                App.db.clear('exercises'),
                                App.db.clear('plans'),
                                App.db.clear('history'),
                            ]);
                            // Save new state
                            // Rehydrate Maps and Sets from the imported JSON structure
                            data.exercises = new Map(data.exercises || []);
                            data.plans = new Map(data.plans || []);
                            data.achievements = new Set(data.achievements || []);

                            await this.save(data);
                            // Re-initialize app with new data
                            // App.init() will call load, which will correctly read the saved Maps/Sets
                            await App.init(); 
                            App.ui.showToast("Daten erfolgreich importiert!", "success");
                        } else { throw new Error("Invalid file structure."); }
                    } catch(err) { 
                        App.ui.showToast("Ung√ºltige oder korrupte Datendatei.", "error");
                        console.error(err);
                    }
                };
                reader.readAsText(file);
            }
        },

        // ===================================================================
        // 3. BUSINESS LOGIC & SCIENTIFIC IMPLEMENTATION
        // ===================================================================
        
        logic: {
            /**
             * Namespace for all user-related logic.
             */
            user: {
                setLevel(level, state) {
                    state.user.level = level;
                    const levelName = { beginner: 'Anf√§nger', intermediate: 'Sportlich', expert: 'Experte' }[level];
                    App.ui.showToast(`Trainingsmodus auf "${levelName}" gesetzt.`, "info");
                    return true; // Added for subtask verification
                },

                updateHydration(amount, state) {
                    state.user.hydration.current = Math.max(0, Math.min(state.user.hydration.goal, state.user.hydration.current + amount));
                }
            },
            
            /**
             * Namespace for all exercise-related logic.
             */
            exercises: {
                create(data, state) {
                    const id = App.logic.utils.generateId('ex');

                    // data might come from a form: { name, muscleGroup, type, equipment, settings_seat, settings_backrest, ... }
                    // Or from an existing object: { name, muscleGroup, type, equipment, settings: { seat, backrest ...}}

                    const exercise = {
                        id: id,
                        name: data.name || 'Unbenannte √úbung',
                        muscleGroup: data.muscleGroup || 'N/A',
                        type: data.type || 'compound', // Default to 'compound'
                        equipmentId: data.equipmentId || null, // Expecting data.equipmentId from the form now

                        settings: {
                            seat: data.settings?.seat ?? data.settings_seat ?? null,
                            backrest: data.settings?.backrest ?? data.settings_backrest ?? null,
                            customSettings: data.settings?.customSettings ?? {}
                        },

                        metrics: {
                            // Assuming data.pr is { weight: X, reps: Y } from old structure, or data.personalRecord is just weight
                            personalRecord: data.metrics?.personalRecord ?? data.pr?.weight ?? 0,
                            averageWeight: data.metrics?.averageWeight ?? 0,
                            totalVolume: data.metrics?.totalVolume ?? 0,
                            // Assuming data.history is the old performance history
                            performanceHistory: data.metrics?.performanceHistory ?? data.history ?? []
                        },

                        biomechanics: {
                            rangeOfMotion: data.biomechanics?.rangeOfMotion ?? 'full', // Default to 'full'
                            tempo: data.biomechanics?.tempo ?? '2-0-2-0', // Default to '2-0-2-0'
                            muscleActivation: {}, // Initially empty, to be filled by calculateMuscleActivation
                            stabilizationDemand: data.biomechanics?.stabilizationDemand ?? 0.5 // Default to 0.5
                        }
                    };

                    // Clean up settings if they were flat in data
                    if (data.settings_seat) delete exercise.settings_seat;
                    if (data.settings_backrest) delete exercise.settings_backrest;

                    state.exercises.set(id, exercise);
                    return exercise;
                },

                async update(exerciseId, data, state) {
                    const exToUpdate = state.exercises.get(exerciseId);

                    if (!exToUpdate) {
                        console.error(`Exercise with ID ${exerciseId} not found for update.`);
                        return null;
                    }

                    // Direct properties
                    if (typeof data.name === 'string') exToUpdate.name = data.name;
                    if (typeof data.muscleGroup === 'string') exToUpdate.muscleGroup = data.muscleGroup;
                    if (typeof data.type === 'string') exToUpdate.type = data.type;
                    // Allow equipmentId to be set to null to remove association
                    if (typeof data.equipmentId !== 'undefined') exToUpdate.equipmentId = data.equipmentId;


                    // Nested 'settings' object
                    if (data.settings && typeof data.settings === 'object') {
                        exToUpdate.settings = { ...exToUpdate.settings, ...data.settings };
                    }
                    // Handle flat settings from older form structures if necessary (e.g. data.settings_seat)
                    // This part can be removed if forms are guaranteed to send nested 'settings'
                    if (typeof data.settings_seat !== 'undefined') exToUpdate.settings.seat = data.settings_seat;
                    if (typeof data.settings_backrest !== 'undefined') exToUpdate.settings.backrest = data.settings_backrest;


                    // Nested 'metrics' object - be careful with performanceHistory
                    if (data.metrics && typeof data.metrics === 'object') {
                        // Only update specific, editable metric fields. Don't overwrite performanceHistory.
                        if (typeof data.metrics.personalRecord !== 'undefined') exToUpdate.metrics.personalRecord = parseFloat(data.metrics.personalRecord) || 0;
                        if (typeof data.metrics.averageWeight !== 'undefined') exToUpdate.metrics.averageWeight = parseFloat(data.metrics.averageWeight) || 0;
                        if (typeof data.metrics.totalVolume !== 'undefined') exToUpdate.metrics.totalVolume = parseFloat(data.metrics.totalVolume) || 0;
                        // performanceHistory should be managed by session logic, not direct edit here.
                    }
                     // Handle flat PR from older form structures
                    if (typeof data.pr?.weight !== 'undefined') exToUpdate.metrics.personalRecord = parseFloat(data.pr.weight) || 0;


                    // Nested 'biomechanics' object
                    if (data.biomechanics && typeof data.biomechanics === 'object') {
                        exToUpdate.biomechanics = { ...exToUpdate.biomechanics, ...data.biomechanics };
                    }
                     // Handle flat biomechanics from older forms if necessary
                    if (typeof data.biomechanics_rangeOfMotion !== 'undefined') exToUpdate.biomechanics.rangeOfMotion = data.biomechanics_rangeOfMotion;
                    if (typeof data.biomechanics_tempo !== 'undefined') exToUpdate.biomechanics.tempo = data.biomechanics_tempo;
                    if (typeof data.biomechanics_stabilizationDemand !== 'undefined') exToUpdate.biomechanics.stabilizationDemand = parseFloat(data.biomechanics_stabilizationDemand) || 0.5;


                    // Persist to DB
                    await App.db.put('exercises', exToUpdate);

                    // The object in state.exercises is already updated by reference.
                    return exToUpdate;
                },

                async deleteExercise(exerciseId, state) {
                    const deletedFromState = state.exercises.delete(exerciseId);
                    if (deletedFromState) {
                        await App.db.delete('exercises', exerciseId);
                        // Logic to remove from plans/sets will be added in the next micro-task.
                    }
                    return deletedFromState;
                },

                calculateMuscleActivation(exerciseData) {
                    const baseActivation = {
                        primary: 1.0,
                        secondary: 0.6,
                        stabilizers: 0.3
                    };

                    const equipmentModifiers = {
                        barbell: 1.0,
                        dumbbell: 0.95,
                        cable: 0.9,
                        machine: 0.85,
                        bodyweight: 1.1,
                        kettlebell: 1.05
                    };

                    const equipmentName = exerciseData.equipment ? String(exerciseData.equipment).toLowerCase() : 'unknown';
                    const modifier = equipmentModifiers[equipmentName] || 1.0;

                    return {
                        ...baseActivation,
                        modifier: modifier
                    };
                },

                calculatePerformanceTrend(performanceHistory) {
                    if (!performanceHistory || performanceHistory.length < 2) {
                        return 'insufficient data'; // Or 'stable' as per preference
                    }

                    const n = performanceHistory.length;
                    let sumX = 0;
                    let sumY = 0;
                    let sumXY = 0;
                    let sumX2 = 0;

                    performanceHistory.forEach((entry, index) => {
                        const x = index;
                        const y = entry.weight; // Assuming 'weight' is the primary metric for trend

                        if (typeof y !== 'number') {
                            // Skip non-numeric entries or handle error
                            // For simplicity, we'll skip here, but a robust solution might need error handling
                            // or ensure data integrity upstream.
                            return;
                        }

                        sumX += x;
                        sumY += y;
                        sumXY += x * y;
                        sumX2 += x * x;
                    });

                    const denominator = (n * sumX2 - sumX * sumX);
                    if (denominator === 0) {
                        return 'stable'; // Avoid division by zero, implies no variance in x or perfect correlation
                    }

                    const slope = (n * sumXY - sumX * sumY) / denominator;

                    // Define thresholds for trend
                    const improvingThreshold = 0.5; // Example: weight increases by 0.5 units per session on average
                    const decliningThreshold = -0.5;

                    if (slope > improvingThreshold) {
                        return 'improving';
                    } else if (slope < decliningThreshold) {
                        return 'declining';
                    } else {
                        return 'stable';
                    }
                }
            },

            exerciseSetManager: { // 5. Create App.logic.exerciseSetManager
                async create(nameString, exerciseIdsArray, state) {
                    const id = App.logic.utils.generateId('ex_set');
                    const newSet = { id, name: nameString, exercises: exerciseIdsArray || [] };
                    state.exerciseSets.set(id, newSet);
                    await App.db.put('exerciseSets', newSet);
                    return newSet;
                },

                get(setId, state) {
                    return state.exerciseSets.get(setId);
                },

                async update(setId, nameString, exerciseIdsArray, state) {
                    if (state.exerciseSets.has(setId)) {
                        const set = state.exerciseSets.get(setId);
                        set.name = nameString;
                        set.exercises = exerciseIdsArray || [];
                        await App.db.put('exerciseSets', set);
                        return set;
                    }
                    return null; // Or throw error
                },

                async deleteSet(setId, state) {
                    if (state.exerciseSets.has(setId)) {
                        state.exerciseSets.delete(setId);
                        await App.db.delete('exerciseSets', setId); // Uses the new App.db.delete
                        return true;
                    }
                    return false;
                }
            },

            equipmentManager: {
                async create(nameString, descriptionString, state) {
                    const id = App.logic.utils.generateId('eqp');
                    const newEquipment = { id, name: nameString, description: descriptionString || '' };
                    state.equipment.set(id, newEquipment);
                    await App.db.put('equipment', newEquipment);
                    return newEquipment;
                },
                get(equipmentId, state) {
                    return state.equipment.get(equipmentId);
                },
                async update(equipmentId, nameString, descriptionString, state) {
                    const item = state.equipment.get(equipmentId);
                    if (item) {
                        item.name = nameString || item.name; // Keep old name if new one is not provided
                        // If descriptionString is explicitly an empty string, update it. Otherwise, keep old if null/undefined.
                        item.description = typeof descriptionString === 'string' ? descriptionString : item.description;
                        await App.db.put('equipment', item);
                        return item;
                    }
                    console.warn(`Equipment with ID ${equipmentId} not found for update.`);
                    return null;
                },
                async deleteItem(equipmentId, state) {
                    const deletedFromState = state.equipment.delete(equipmentId);
                    if (deletedFromState) {
                        await App.db.delete('equipment', equipmentId);
                        // TODO: Consider implications for exercises using this equipment.
                        // For now, exercises will simply store the equipment ID.
                        // UI rendering or logic might need to handle cases where an equipment ID
                        // points to a non-existent item if not unlinked.
                    }
                    return deletedFromState;
                }
            },
        
            /**
             * Namespace for all plan-related logic.
             */
            plans: {
                // --- Helper Functions for Optimal Settings ---
                calculateOptimalSets(exerciseData, userLevel) {
                    const type = exerciseData?.type || 'compound';
                    const level = userLevel || 'intermediate';

                    if (type === 'compound') {
                        if (level === 'beginner') return 3;
                        if (level === 'intermediate') return 4;
                        if (level === 'expert') return 5;
                    } else { // isolation
                        if (level === 'beginner') return 2;
                        if (level === 'intermediate') return 3;
                        if (level === 'expert') return 4;
                    }
                    return 3; // Default
                },

                calculateOptimalReps(exerciseData, planGoal = 'hypertrophy') {
                    // exerciseData.type could be used for more specific tuning if needed
                    // planGoal can be 'strength', 'hypertrophy', 'endurance', or plan types like 'push', 'fullbody'

                    let goal = planGoal;
                    // Simple mapping from plan type/targetVolume to goal if needed
                    if (['push', 'pull', 'legs', 'fullbody', 'custom', 'moderate'].includes(planGoal)) {
                        goal = 'hypertrophy'; // Default to hypertrophy for common plan types/moderate volume
                    }

                    if (goal === 'strength') return '3-5';
                    if (goal === 'hypertrophy') return '8-12';
                    if (goal === 'endurance') return '15-20';

                    return '8-12'; // Default
                },

                calculateOptimalRest(exerciseData, userLevel) {
                    const type = exerciseData?.type || 'compound';
                    // userLevel could be used for more specific tuning if needed

                    if (type === 'compound') return 90; // seconds
                    if (type === 'isolation') return 60; // seconds

                    return 75; // Default
                },

                optimizePlanOrder(plan, state) {
                    // Modifies plan.exercises in place
                    // Sorts by compound first, then by original order (implicitly, if stable sort)
                    // More complex sorting could involve muscle group size, exercise difficulty etc.
                    plan.exercises.sort((a, b) => {
                        const exA_Data = state.exercises.get(a.id);
                        const exB_Data = state.exercises.get(b.id);

                        if (!exA_Data || !exB_Data) return 0; // Should not happen if data is consistent

                        const typeA = exA_Data.type === 'compound' ? 0 : 1;
                        const typeB = exB_Data.type === 'compound' ? 0 : 1;

                        if (typeA !== typeB) {
                            return typeA - typeB; // Compound exercises first
                        }
                        return a.order - b.order; // Preserve original order among same types initially
                    });
                    // Re-assign order property
                    plan.exercises.forEach((ex, index) => {
                        ex.order = index;
                    });
                },

                // --- Main CRUD for Plans ---
                async create(data, state) {
                    const id = App.logic.utils.generateId('plan');
                    const now = Date.now();

                    const plan = {
                        id,
                        name: data.name || 'Unbenannter Plan',
                        description: data.description || '',
                        exercises: [], // Initially empty, added via addExerciseToPlan or UI
                        type: data.type || 'custom', // Default plan type
                        variables: data.variables || { targetVolume: 'moderate', intensity: 'moderate' },
                        periodization: {
                            type: data.periodizationType || 'linear', // Default periodization
                            currentWeek: 1,
                            cycleLength: data.cycleLength || 4, // Default cycle length
                            phases: [] // To be populated
                        },
                        autoRegulation: data.autoRegulation || { enabled: true, rpeTarget: 7 },
                        created: now,
                        lastModified: now,
                        analytics: {
                            timesCompleted: 0,
                            totalVolumeLifted: 0,
                            averageDurationMinutes: 0
                        }
                    };

                    // Populate periodization phases
                    plan.periodization.phases = this.generatePeriodizationPhases(plan); // 'this' refers to App.logic.plans

                    state.plans.set(id, plan);
                    await App.db.put('plans', plan); // Persist to IndexedDB
                    return plan;
                },

                generatePeriodizationPhases(planData) {
                    const phases = [];
                    const type = planData.periodization.type || 'linear';
                    const cycleLength = planData.periodization.cycleLength || 4; // Default 4 weeks

                    switch (type) {
                        case 'linear':
                            const baseVolumeLinear = 10; // Example base volume
                            for (let week = 1; week <= cycleLength; week++) {
                                phases.push({
                                    week,
                                    volumeFactor: 1.0 + (week - 1) * 0.1, // e.g., 1.0, 1.1, 1.2, 1.3
                                    intensityPercent: 70 + (week - 1) * 5, // e.g., 70, 75, 80, 85
                                    focus: (week === cycleLength) ? 'deload' : 'accumulation'
                                });
                            }
                            // Ensure the last week is a deload by adjusting factors
                            if (cycleLength > 1 && phases[cycleLength-1].focus === 'deload') {
                                phases[cycleLength-1].volumeFactor = 0.7; // Significantly lower volume
                                phases[cycleLength-1].intensityPercent = 60; // Lower intensity
                            }
                            break;
                        case 'undulating':
                            // For undulating, each week in the cycle could represent the structure for that week
                            // The daily split (A,B,C) would be applied by the session starter logic
                            for (let week = 1; week <= cycleLength; week++) {
                                phases.push({
                                    week,
                                    type: 'undulating',
                                    // Daily structure hint, actual application in session logic
                                    dailyStructure: [
                                        { day: 'A', focus: 'hypertrophy', reps: '8-12', intensityPercentRPE: '70-80 (RPE 7-8)' },
                                        { day: 'B', focus: 'strength', reps: '3-5', intensityPercentRPE: '80-90 (RPE 8-9)' },
                                        { day: 'C', focus: 'endurance', reps: '15-20', intensityPercentRPE: '60-70 (RPE 6-7)' }
                                    ],
                                    focus: `Week ${week} Undulating Focus`
                                });
                            }
                            break;
                        case 'block':
                            // Example block periodization: 3 blocks, cycleLength would be total weeks for these blocks
                            const totalBlockWeeks = cycleLength;
                            const accumulationWeeks = Math.ceil(totalBlockWeeks * 0.5); // 50%
                            const intensificationWeeks = Math.floor(totalBlockWeeks * 0.3); // 30%
                            const realizationWeeks = Math.max(1, totalBlockWeeks - accumulationWeeks - intensificationWeeks); // Remaining, at least 1

                            if (accumulationWeeks > 0) phases.push({ blockName: 'Accumulation', durationWeeks: accumulationWeeks, focus: 'volume', intensity: 'moderate', volumeFactor: 1.2, intensityPercent: 70 });
                            if (intensificationWeeks > 0) phases.push({ blockName: 'Intensification', durationWeeks: intensificationWeeks, focus: 'intensity', intensity: 'high', volumeFactor: 1.0, intensityPercent: 85 });
                            if (realizationWeeks > 0) phases.push({ blockName: 'Realization', durationWeeks: realizationWeeks, focus: 'peak', intensity: 'very_high', volumeFactor: 0.8, intensityPercent: 90 });
                            break;
                        default:
                            // Default to a simple linear if type is unknown, or empty phases
                            for (let week = 1; week <= cycleLength; week++) {
                                phases.push({ week, volumeFactor: 1.0, intensityPercent: 70, focus: 'standard' });
                            }
                            break;
                    }
                    return phases;
                },

                // --- CRUD for Exercises within a Plan ---
                async addExerciseToPlan(planId, exerciseId, configuration = {}, state) {
                    const plan = state.plans.get(planId);
                    if (!plan) {
                        console.error(`Plan with ID ${planId} not found.`);
                        return null;
                    }
                    const exerciseData = state.exercises.get(exerciseId);
                    if (!exerciseData) {
                        console.error(`Exercise with ID ${exerciseId} not found.`);
                        return null;
                    }

                    // Determine plan goal for optimal reps. Use plan.variables.targetVolume or plan.type as a proxy.
                    let planGoal = 'hypertrophy'; // Default
                    if (plan.variables && plan.variables.targetVolume) {
                        planGoal = plan.variables.targetVolume; // e.g., 'strength', 'hypertrophy', 'endurance'
                    } else if (plan.type) {
                         // Simple mapping if plan.type is like 'strength training' etc.
                        if (plan.type.toLowerCase().includes('strength')) planGoal = 'strength';
                        else if (plan.type.toLowerCase().includes('endurance')) planGoal = 'endurance';
                    }


                    const sets = configuration.sets || this.calculateOptimalSets(exerciseData, state.user.level);
                    const reps = configuration.reps || this.calculateOptimalReps(exerciseData, planGoal);
                    const rest = configuration.restTime || this.calculateOptimalRest(exerciseData, state.user.level);

                    // Use a unique ID for the plan exercise entry if needed for precise updates/deletions.
                    // For now, exerciseId (original exercise ID) is used, assuming one instance per plan or simple updates.
                    // If multiple instances of the same exercise are allowed with different configs, planExercise.id should be unique.
                    const planExercise = {
                        id: exerciseId, // This is the ID of the exercise in the main exercises list
                        // entryId: App.logic.utils.generateId('plan_ex_entry'), // Optional: for unique identification within the plan
                        sets,
                        reps,
                        rest,
                        order: plan.exercises.length // Initial order
                    };

                    plan.exercises.push(planExercise);
                    this.optimizePlanOrder(plan, state); // Re-sort and update order

                    plan.lastModified = Date.now();
                    await App.db.put('plans', plan);
                    return plan;
                },

                async removeExerciseFromPlan(planId, exerciseIdToRemove, state) { // Assuming exerciseIdToRemove is the ID of the exercise in the plan's list
                    const plan = state.plans.get(planId);
                    if (!plan) {
                        console.error(`Plan with ID ${planId} not found.`);
                        return null;
                    }

                    const initialLength = plan.exercises.length;
                    // If using unique entryId: plan.exercises = plan.exercises.filter(ex => ex.entryId !== exerciseIdToRemove);
                    // Current logic: remove based on the exercise's main ID. This might remove multiple if duplicates exist.
                    // For this version, we'll assume we remove the first found instance if IDs are not unique per entry.
                    // Or, if exerciseIdToRemove is meant to be the actual exercise ID, filter all matching.
                    // The current UI (from Trainingsboy_v0) seems to imply removing by the exercise's own ID.
                    const exerciseIndex = plan.exercises.findIndex(ex => ex.id === exerciseIdToRemove);
                    if (exerciseIndex > -1) {
                        plan.exercises.splice(exerciseIndex, 1);
                    }

                    if (plan.exercises.length < initialLength) {
                        this.optimizePlanOrder(plan, state); // Re-order
                        plan.lastModified = Date.now();
                        await App.db.put('plans', plan);
                    }
                    return plan;
                },

                async updateExerciseInPlan(planId, exerciseIdToUpdate, field, value, state) {
                    // exerciseIdToUpdate refers to the 'id' field of the exercise object within plan.exercises array
                    const plan = state.plans.get(planId);
                    if (!plan) {
                        console.error(`Plan with ID ${planId} not found.`);
                        return null;
                    }

                    const exerciseEntry = plan.exercises.find(ex => ex.id === exerciseIdToUpdate);

                    if (exerciseEntry) {
                        if (field === 'sets' || field === 'rest') {
                            exerciseEntry[field] = parseInt(value, 10);
                        } else {
                            exerciseEntry[field] = value;
                        }
                        plan.lastModified = Date.now();
                        await App.db.put('plans', plan);
                    } else {
                        console.warn(`Exercise entry with ID ${exerciseIdToUpdate} not found in plan ${planId}.`);
                    }
                    return plan;
                }
            },
            
            /**
             * Namespace for workout session management.
             */
            session: {
                async start(planId, state) {
                    const plan = state.plans.get(planId);
                    if (!plan) {
                        console.error(`Plan with ID ${planId} not found.`);
                        App.ui.showToast("Fehler: Plan nicht gefunden!", "error");
                        return false;
                    }
                    if (plan.exercises.length === 0) {
                        App.ui.showToast("Dieser Plan hat keine √úbungen!", "error");
                        return false;
                    }

                    state.session = {
                        planId: plan.id,
                        planName: plan.name,
                        startTime: Date.now(),
                        currentExIndex: 0,
                        exercises: [], // Populated below
                        // Example default biometrics for the session
                        biometrics: {
                            hydration: { consumed: 0, target: 2000 }, // Default 2000ml, or use a helper
                            sleepHours: state.user.avgSleepHours || 7, // Example: pull from user profile or default
                            stressLevel: 'low', // Default or from pre-workout survey
                        },
                        environment: {
                            location: 'home_gym', // Default
                            temperature: 20, // Celsius, default
                        },
                        notes: '' // User notes for the session
                    };

                    for (const planEx of plan.exercises) {
                        const coreExerciseData = state.exercises.get(planEx.id);
                        if (!coreExerciseData) {
                            console.warn(`Core exercise data for ID ${planEx.id} not found. Skipping.`);
                            continue;
                        }
                        // Determine target weight using periodization if available
                        let targetWeight = App.logic.analytics.calculateNextTargetWeight(coreExerciseData, planEx.reps, state.user.level);
                        const currentPeriodizationPhase = plan.periodization?.phases?.[plan.periodization.currentWeek -1];
                        if (currentPeriodizationPhase?.intensityPercent && coreExerciseData.metrics?.personalRecord > 0) {
                            // Apply periodization factor to 1RM estimate or PR
                            // Simplified: apply to PR if available, otherwise use default targetWeight
                            // A more robust approach would use a 1RM estimate based on performanceHistory
                            targetWeight = (coreExerciseData.metrics.personalRecord * (currentPeriodizationPhase.intensityPercent / 100)).toFixed(1);
                        }


                        state.session.exercises.push({
                            exerciseId: planEx.id,
                            exerciseName: coreExerciseData.name,
                            plannedSets: planEx.sets,
                            targetReps: planEx.reps,    // Rep range string like "8-12"
                            targetRest: planEx.rest,    // Rest time in seconds
                            targetWeight: parseFloat(targetWeight) || 20, // Ensure it's a number, default if calculation fails
                            targetTempo: coreExerciseData.biomechanics?.tempo || '2-0-2-0', // From exercise definition
                            completedSets: [],
                            // Other fields from coreExerciseData can be copied if needed for quick access during session
                            // e.g., type: coreExerciseData.type
                        });
                    }

                    // App.render(); // UI should be updated by the caller based on state change
                    console.log(`Session started for plan: ${plan.name}`, state.session);
                    state.session.breathingExerciseRecommended = false; // Initialize for the session
                    return true; // Indicate success
                },

                calculateVelocityMetrics(setData, coreExerciseData) {
                    const rpe = setData.rpe || 7;
                    let basePeakVelocity = 1.0;
                    if (coreExerciseData && coreExerciseData.type === 'isolation') { basePeakVelocity = 0.8; }

                    // Ensure RPE is within a reasonable range for calculation (e.g., 1-10)
                    const normalizedRpe = Math.max(1, Math.min(10, rpe));

                    const peakVelocity = Math.max(0.1, basePeakVelocity - (normalizedRpe - 5) * 0.11);
                    const meanVelocity = Math.max(0.08, peakVelocity * 0.8 - (normalizedRpe - 5) * 0.05);
                    const powerOutput = (setData.weight || 0) * 9.81 * meanVelocity; // Simplified power

                    const freshMeanVelocityEstimate = Math.max(0.1, (basePeakVelocity * 0.8));
                    const fatigueIndex = Math.max(0, 1 - (meanVelocity / freshMeanVelocityEstimate));

                    return {
                        peakVelocity: parseFloat(peakVelocity.toFixed(2)),
                        meanVelocity: parseFloat(meanVelocity.toFixed(2)),
                        powerOutput: parseFloat(powerOutput.toFixed(1)),
                        fatigueIndex: parseFloat(fatigueIndex.toFixed(2))
                    };
                },

                async performSet(exerciseIndex, setData, state) {
                    const session = state.session;
                    if (!session) {
                        console.error("No active session to perform set.");
                        return { success: false, error: "No active session." };
                    }
                    const currentSessionExercise = session.exercises[exerciseIndex];
                    if (!currentSessionExercise) {
                        console.error(`Exercise at index ${exerciseIndex} not found in current session.`);
                        return { success: false, error: `Exercise at index ${exerciseIndex} not found.`};
                    }

                    const coreExerciseData = state.exercises.get(currentSessionExercise.exerciseId);

                    // setData: { weight: Number, reps: Number, rpe: Number, formQuality: Number, tempo: String }
                    const completedSet = {
                        setNumber: currentSessionExercise.completedSets.length + 1,
                        weight: parseFloat(setData.weight) || 0,
                        reps: parseInt(setData.reps, 10) || 0,
                        rpe: parseFloat(setData.rpe) || null,
                        formQuality: parseFloat(setData.formQuality) || 8, // Default form quality
                        tempo: setData.tempo || currentSessionExercise.targetTempo || '2-0-2-0',
                        timestamp: Date.now(),
                        volume: (parseFloat(setData.weight) || 0) * (parseInt(setData.reps, 10) || 0),
                        velocityMetrics: this.calculateVelocityMetrics(setData, coreExerciseData)
                    };

                    currentSessionExercise.completedSets.push(completedSet);

                    // Auto-Regulation for next set's target weight (if applicable)
                    const newTargetWeight = App.logic.analytics.calculateAutoregulatedWeight(
                        String(currentSessionExercise.targetWeight), // Ensure string for function
                        completedSet.rpe
                    );
                    currentSessionExercise.targetWeight = parseFloat(newTargetWeight);

                    // Calculate effective rest time for UI timer
                    const actualRestDuration = App.logic.analytics.calculateRestDuration(
                        currentSessionExercise.targetRest,
                        completedSet.rpe
                    );

                    // Conceptual: App.ui.startRestTimer(actualRestDuration);
                    // The actual UI call is handled by the event listener in addEventListeners which calls App.ui.handleSetCompletion,
                    // which in turn calls this logic function (performSet), then App.ui.startRestTimer.
                    // So, no direct App.ui call here to avoid circular dependencies or misplaced responsibilities.

                    console.log(`Set ${completedSet.setNumber} performed for ${currentSessionExercise.exerciseName}: ${completedSet.volume}kg volume. Next target weight: ${currentSessionExercise.targetWeight}kg. Suggested rest: ${actualRestDuration}s.`);
                    // Note: state.session is directly mutated. Full save to DB typically happens on session.finishSession().
                    return { success: true, calculatedRest: actualRestDuration };
                },
                
                addToQuickSet(exId, state) {
                    if (!state.quickSet.includes(exId)) state.quickSet.push(exId);
                     App.render(); // Re-render to show item in quick set UI if needed
                },

                async startQuickSet() { // Made async to align with start method
                    if (App.state.quickSet.length === 0) { 
                        App.ui.showToast("Keine √úbungen im Set.", "error"); 
                        return; 
                    }
                    const quickPlan = {
                        id: 'quick_set_runtime', // Use a distinct ID for runtime plans
                        name: 'Schnelles Set',
                        exercises: App.state.quickSet.map(exId => {
                            const coreEx = App.state.exercises.get(exId);
                            return {
                                id: exId,
                                sets: App.logic.plans.calculateOptimalSets(coreEx, App.state.user.level),
                                reps: App.logic.plans.calculateOptimalReps(coreEx, 'hypertrophy'), // Default goal
                                rest: App.logic.plans.calculateOptimalRest(coreEx, App.state.user.level)
                            };
                        })
                    };
                    // Temporarily add plan to state (not DB) for the session to use
                    App.state.plans.set(quickPlan.id, quickPlan);

                    const success = await this.start(quickPlan.id, App.state); // Pass state
                    if (success) {
                        App.state.ui.currentView = 'training'; // Navigate to training view
                        App.render();
                    } else {
                        // Clean up temporary plan if session start failed
                        App.state.plans.delete(quickPlan.id);
                    }
                },
        
                // This performSet is called by UI. It should call the main async performSet.
                // For now, this is kept as is, but ideally, UI would call a wrapper that calls the async performSet.
                // Or, this function is refactored to use the async performSet.
                // For this subtask, we are modifying the *other* performSet.
                // The subtask description refers to performSet(exerciseIndex, setData, state)
                // This one is performSet(exIndex, setIndex, setData)
                // NO CHANGE HERE FOR THIS SUBTASK for this specific performSet(exIndex, setIndex, setData)
                performSet(exIndex, setIndex, setData) { // THIS IS THE UI-CALLED ONE, NOT THE ONE WE ADDED VELOCITY TO
                    const session = App.state.session;
                    if (!session) return;
                    const ex = session.exercises[exIndex];
                    const setWithVolume = { ...setData, time: Date.now(), volume: setData.weight * setData.reps };

                    // If this function is still meant to be the primary way sets are recorded from UI,
                    // it would need to be adapted to call the new `async performSet` or replicate its logic,
                    // including velocity metrics. For now, leaving it as is to minimize unintended breakage.
                    // This likely means velocity metrics won't be populated if this function is what's directly triggered by UI.
                    // This is a point for future refactoring.
                    ex.completedSets[setIndex] = setWithVolume;


                    // Autoregulation
                    const newTargetWeight = App.logic.analytics.calculateAutoregulatedWeight(String(ex.targetWeight), setData.rpe);
                    if (parseFloat(newTargetWeight) !== ex.targetWeight) {
                        ex.targetWeight = parseFloat(newTargetWeight);
                        App.ui.showToast(`üí° Gewicht f√ºr n√§chsten Satz auf ${newTargetWeight}kg angepasst.`, "info");
                    }
                    
                    // Start Rest Timer with adjusted duration
                    const restDuration = App.logic.analytics.calculateRestDuration(ex.targetRest, setData.rpe);
                    App.ui.startRestTimer(restDuration);
                    App.render();
                },
        
                async nextExercise(state) {
                    const session = state.session;
                    if (!session) {
                        return { status: 'no_session', breathingRecommended: false };
                    }

                    // Reset or ensure breathing recommendation is specific to this transition
                    session.breathingExerciseRecommended = false;

                    const lastExercise = session.exercises[session.currentExIndex];
                    if (lastExercise && lastExercise.completedSets && lastExercise.completedSets.length > 0) {
                        let totalRpe = 0;
                        let validSets = 0;
                        lastExercise.completedSets.forEach(s => {
                            if (typeof s.rpe === 'number' && !isNaN(s.rpe)) {
                                totalRpe += s.rpe;
                                validSets++;
                            }
                        });
                        if (validSets > 0) {
                            const avgRpe = totalRpe / validSets;
                            if (avgRpe >= 8.0) { // RPE threshold for breathing exercise
                                session.breathingExerciseRecommended = true;
                                App.ui.showBreathingGuide(); // Directly trigger UI from logic as per existing pattern
                            }
                        }
                    }

                    session.currentExIndex++;

                    if (session.currentExIndex >= session.exercises.length) {
                        await this.finishSession(state); // Ensure state is passed
                        // App.render() is called within finishSession
                        return { status: 'finished', breathingRecommended: session.breathingExerciseRecommended };
                    } else {
                        App.render(); // Render the next exercise screen
                        return { status: 'next', breathingRecommended: session.breathingExerciseRecommended, nextExerciseIndex: session.currentExIndex };
                    }
                },
                
                skipRest() {
                    // Logic function should primarily manage state or complex operations.
                    // UI hiding is better handled in App.ui.hideRestTimer directly or called by this.
                    // For now, this directly calls the UI hide function as per previous structure.
                    App.ui.hideRestTimer();
                },
        
                async finishSession(state) {
                    const session = state.session;
                    if (!session) return;

                    session.endTime = Date.now();
                    session.duration = session.endTime - session.startTime;

                    // Initialize session summary
                    session.summary = {
                        totalVolume: 0,
                        totalSets: 0,
                        totalReps: 0,
                        avgRPE: 0,
                        musclesWorked: new Set(),
                        caloriesBurned: 0,
                        workoutDurationMinutes: parseFloat((session.duration / 60000).toFixed(1))
                    };

                    let rpeSum = 0;
                    let rpeCount = 0;

                    // Process completed exercises for summary and detailed metrics
                    for (const completedEx of session.exercises) {
                        const coreExercise = state.exercises.get(completedEx.exerciseId);
                        if (coreExercise) {
                            session.summary.musclesWorked.add(coreExercise.muscleGroup);
                            let exerciseUpdated = false;
                            completedEx.completedSets.forEach(set => {
                                session.summary.totalVolume += set.volume || 0;
                                session.summary.totalSets++;
                                session.summary.totalReps += set.reps || 0;
                                if (set.rpe !== null && !isNaN(set.rpe)) {
                                    rpeSum += set.rpe;
                                    rpeCount++;
                                }

                                // Update core exercise metrics
                                coreExercise.metrics.performanceHistory.push({
                                    timestamp: set.timestamp,
                                    weight: set.weight,
                                    reps: set.reps,
                                    rpe: set.rpe,
                                    velocityMetrics: set.velocityMetrics // Persist VBT if available
                                });
                                coreExercise.metrics.totalVolume = (coreExercise.metrics.totalVolume || 0) + (set.volume || 0);
                                if (set.weight > (coreExercise.metrics.personalRecord || 0)) {
                                    coreExercise.metrics.personalRecord = set.weight;
                                    if (!state.achievements.has('new_pr')) {
                                        App.ui.showToast("üèÜ Neuer pers√∂nlicher Rekord!", "success");
                                        state.achievements.add('new_pr');
                                    }
                                }
                                exerciseUpdated = true;
                            });
                            if (exerciseUpdated) {
                                await App.db.put('exercises', coreExercise);
                            }
                        }
                    }

                    if (rpeCount > 0) {
                        session.summary.avgRPE = parseFloat((rpeSum / rpeCount).toFixed(1));
                    }
                    session.summary.musclesWorked = Array.from(session.summary.musclesWorked); // Convert Set to Array for storage

                    // Estimate calories burned
                    session.summary.caloriesBurned = this.analytics.estimateCaloriesBurned(session.summary, state.user, session.duration);

                    // Generate recovery recommendations
                    session.recoveryRecommendations = this.analytics.generateRecoveryRecommendations(session, state.user);

                    // Initialize user stats if not present
                    if (!state.user.stats) {
                        state.user.stats = {
                            totalWorkouts: 0,
                            totalVolume: 0,
                            totalDurationMinutes: 0,
                            currentStreak: 0,
                            bestStreak: 0,
                            lastWorkoutDate: null // YYYY-MM-DD format
                        };
                    }

                    // Update user stats
                    const today = new Date().toISOString().slice(0, 10);
                    if (state.user.stats.lastWorkoutDate) {
                        const lastWorkout = new Date(state.user.stats.lastWorkoutDate);
                        const yesterday = new Date();
                        yesterday.setDate(yesterday.getDate() - 1);
                        if (lastWorkout.toISOString().slice(0,10) === yesterday.toISOString().slice(0,10)) {
                            state.user.stats.currentStreak = (state.user.stats.currentStreak || 0) + 1;
                        } else if (state.user.stats.lastWorkoutDate !== today) { // Not same day and not yesterday
                            state.user.stats.currentStreak = 1; // Reset if not consecutive and not same day
                        }
                        // If it's the same day, currentStreak remains unchanged until next day.
                    } else {
                         state.user.stats.currentStreak = 1; // First workout
                    }
                    if (state.user.stats.currentStreak > (state.user.stats.bestStreak || 0)) {
                        state.user.stats.bestStreak = state.user.stats.currentStreak;
                    }
                    state.user.stats.lastWorkoutDate = today;
                    state.user.stats.totalWorkouts = (state.user.stats.totalWorkouts || 0) + 1;
                    state.user.stats.totalVolume = (state.user.stats.totalVolume || 0) + session.summary.totalVolume;
                    state.user.stats.totalDurationMinutes = (state.user.stats.totalDurationMinutes || 0) + session.summary.workoutDurationMinutes;


                    // Persist session to history
                    await App.db.put('history', session);
                    state.history.push(session);
                    
                    // Clean up quick set plan if used
                    const planToClean = state.plans.get(session.planId);
                    if (planToClean && planToClean.id === 'quick_set_runtime') {
                         state.plans.delete(session.planId);
                    }
                    state.quickSet = [];

                    // Calculate progress metrics before clearing session and saving
                    await App.logic.analytics.calculateProgressMetrics(state); // Use the passed state

                    state.session = null; // Clear current session
                    
                    App.ui.showWorkoutCompleteModal(session);
                    await App.storage.save(state); // This will save updated user.stats and trainingMetrics
                    App.render();
                }
            },
            
            /**
             * Namespace for all analytics and scientific calculations.
             */
            analytics: {
                estimateCaloriesBurned(sessionSummary, userData, durationMs) {
                    const weightTrainingMET = 6.0; // General MET for weight training
                    const userWeightKg = userData.weightKg || 75; // Default to 75kg if not specified
                    const hours = durationMs / 3600000;

                    // Adjust MET based on average RPE (intensity)
                    // RPE 7 is baseline, lower RPEs reduce MET, higher RPEs increase MET
                    const rpeFactor = (sessionSummary.avgRPE || 7) / 7;
                    const adjustedMET = weightTrainingMET * rpeFactor;

                    const calories = adjustedMET * userWeightKg * hours;
                    return Math.round(calories);
                },

                generateRecoveryRecommendations(sessionData, userData) {
                    const recommendations = {
                        nutrition: [],
                        hydration: "Trinke ausreichend Wasser √ºber den Tag verteilt, mindestens 2-3 Liter.",
                        sleep: "Versuche, 7-9 Stunden qualitativen Schlaf zu bekommen.",
                        activity: []
                    };

                    const volume = sessionData.summary.totalVolume || 0;
                    const durationMinutes = sessionData.summary.workoutDurationMinutes || 0;
                    const avgRPE = sessionData.summary.avgRPE || 0;

                    // Nutrition
                    if (volume > 5000) { // High volume
                        recommendations.nutrition.push("Konzentriere dich auf eine proteinreiche Mahlzeit (ca. 20-40g Protein) innerhalb von 1-2 Stunden nach dem Training.");
                        recommendations.nutrition.push("F√ºlle deine Glykogenspeicher mit komplexen Kohlenhydraten auf (z.B. Vollkornprodukte, S√º√ükartoffeln).");
                    } else if (volume > 2000) { // Moderate volume
                        recommendations.nutrition.push("Eine ausgewogene Mahlzeit mit Protein und Kohlenhydraten wird empfohlen.");
                    } else {
                        recommendations.nutrition.push("Achte auf eine generell ausgewogene Ern√§hrung.");
                    }

                    // Hydration
                    if (durationMinutes > 60 || avgRPE > 7) {
                        recommendations.hydration = `Du hast intensiv trainiert! Achte besonders auf deine Fl√ºssigkeitszufuhr und erw√§ge elektrolythaltige Getr√§nke, wenn du stark geschwitzt hast. Mindestens 2.5-3.5 Liter heute.`;
                    }

                    // Sleep
                    if (avgRPE > 8) {
                        recommendations.sleep = "Dein Training war sehr intensiv. Priorisiere deinen Schlaf (mind. 8 Stunden), um die Regeneration zu maximieren.";
                    }

                    // Activity / Stretching
                    if (sessionData.summary.musclesWorked && sessionData.summary.musclesWorked.length > 0) {
                        const muscles = sessionData.summary.musclesWorked.join(', ');
                        recommendations.activity.push(`Leichtes Dehnen oder Foam Rolling f√ºr die beanspruchten Muskelgruppen (${muscles}) kann die Erholung f√∂rdern.`);
                    }
                    if (avgRPE < 7 && durationMinutes > 30) {
                         recommendations.activity.push("Ein lockerer Spaziergang oder leichte Cardio-Einheit am n√§chsten Tag kann die aktive Erholung unterst√ºtzen.");
                    }


                    return recommendations;
                },

                calculateAutoregulatedWeight(currentWeightStr, rpe) {
                    let newWeight = parseFloat(currentWeightStr);
                    if (rpe >= 9) newWeight *= 0.95; // 5% reduction
                    else if (rpe <= 6) newWeight *= 1.05; // 5% increase
                    return newWeight.toFixed(1);
                },

                calculateRestDuration(baseRest, rpe) {
                    let duration = baseRest;
                    if (rpe > 8) duration += 30; // 30s bonus for RPE > 8
                    return duration;
                },

                calculateNextTargetWeight(exerciseData, targetRepsStr, userLevel) {
                    if (!exerciseData || exerciseData.history.length === 0) return 20;
                    const targetReps = parseInt(String(targetRepsStr).split('-')[0]);
                    const lastGoodSet = [...exerciseData.history]
                        .filter(h => h.reps >= targetReps)
                        .sort((a,b) => b.time - a.time)[0]; // Most recent good set
                    
                    if (!lastGoodSet) return exerciseData.pr.weight > 0 ? (exerciseData.pr.weight * 0.9).toFixed(1) : 20;

                    const progressionRate = { beginner: 1.025, intermediate: 1.05, expert: 1.075 }[userLevel];
                    return (lastGoodSet.weight * progressionRate).toFixed(1);
                },

                getDashboardStats(state) {
                    const totalWorkouts = state.history.length;
                    const totalVolume = state.history.reduce((sum, wo) => sum + this.getWorkoutVolume(wo), 0);
                    const bestLift = Math.max(0, ...Array.from(state.exercises.values()).map(ex => ex.pr?.weight || 0));
                    return { totalWorkouts, totalVolume, bestLift };
                },

                getWorkoutVolume(workout) {
                    return workout.exercises.reduce((sum, ex) => sum + (ex.completedSets || []).reduce((s, set) => s + (set.weight * set.reps), 0), 0);
                },

                getWeeklyVolume(history) {
                    const weeks = {};
                    history.forEach(w => {
                        const d = new Date(w.startTime);
                        const weekStart = new Date(d.setDate(d.getDate() - (d.getDay() === 0 ? 6 : d.getDay() - 1))).toISOString().split('T')[0];
                        if (!weeks[weekStart]) weeks[weekStart] = 0;
                        weeks[weekStart] += this.getWorkoutVolume(w);
                    });
                    return Object.entries(weeks).sort((a, b) => new Date(a[0]) - new Date(b[0])).slice(-12);
                },

                getStrengthProgress(exercises) {
                    const mainCompound = Array.from(exercises.values())
                        .filter(ex => ex.type === 'compound' && ex.history.length > 2)
                        .sort((a,b) => b.history.length - a.history.length)[0];

                    if (!mainCompound) return null;

                    const data = mainCompound.history.map(set => ({
                        x: set.time,
                        y: set.weight * (1 + set.reps / 30) // Epley 1RM estimation
                    }));
                    return { label: `Gesch√§tztes 1RM (${mainCompound.name})`, data };
                },

                getHeatmapData(history) {
                    const counts = {};
                    const sixMonthsAgo = new Date();
                    sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
                    history.forEach(w => {
                        const d = new Date(w.startTime);
                        if (d < sixMonthsAgo) return;
                        const dateString = d.toISOString().split('T')[0];
                        counts[dateString] = (counts[dateString] || 0) + 1;
                    });
                    return counts;
                },

                getMuscleFocus(history, exercises) {
                    const focus = {};
                    history.slice(-10).forEach(wo => {
                        wo.exercises.forEach(ex => {
                            const exData = exercises.get(ex.id);
                            if (exData) {
                                if (!focus[exData.muscleGroup]) focus[exData.muscleGroup] = 0;
                                focus[exData.muscleGroup]++;
                            }
                        });
                    });
                    return focus;
                },

                estimateOneRepMax(exercisePerformanceHistory) {
                    if (!exercisePerformanceHistory || exercisePerformanceHistory.length === 0) {
                        return 0;
                    }

                    let maxOneRM = 0;
                    exercisePerformanceHistory.forEach(entry => {
                        if (entry && typeof entry.weight === 'number' && typeof entry.reps === 'number' && entry.reps > 0) {
                            // Epley formula: 1RM = weight * (1 + reps / 30)
                            const oneRM = entry.weight * (1 + entry.reps / 30);
                            if (oneRM > maxOneRM) {
                                maxOneRM = oneRM;
                            }
                        }
                    });
                    return parseFloat(maxOneRM.toFixed(1));
                },

                calculateProgressRate(exercisePerformanceHistory, weeksConsidered = 4) {
                    if (!exercisePerformanceHistory || exercisePerformanceHistory.length < 2) {
                        return 0; // Or 'insufficient_data'
                    }

                    const now = Date.now();
                    const startTimeOfPeriod = now - (weeksConsidered * 7 * 24 * 60 * 60 * 1000);

                    const recentHistory = exercisePerformanceHistory.filter(entry => entry.timestamp >= startTimeOfPeriod);

                    if (recentHistory.length < 2) {
                        return 0; // Or 'insufficient_data_in_period'
                    }

                    // Sort by timestamp to ensure correct order for regression
                    recentHistory.sort((a,b) => a.timestamp - b.timestamp);

                    const firstEntryTime = recentHistory[0].timestamp;

                    const dataPoints = recentHistory.map(entry => {
                        // Calculate 1RM for each set/entry
                        const estimated1RM = entry.weight * (1 + entry.reps / 30);
                        // Time value in days from the start of the relevant history period
                        const timeValueInDays = (entry.timestamp - firstEntryTime) / (24 * 60 * 60 * 1000);
                        return { x: timeValueInDays, y: estimated1RM };
                    });

                    if (dataPoints.length < 2) return 0;

                    let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                    const n = dataPoints.length;

                    dataPoints.forEach(p => {
                        sumX += p.x;
                        sumY += p.y;
                        sumXY += p.x * p.y;
                        sumX2 += p.x * p.x;
                    });

                    const denominator = (n * sumX2 - sumX * sumX);
                    if (denominator === 0) {
                        return 0; // No change or vertical line, slope is undefined or 0
                    }
                    const slopePerDay = (n * sumXY - sumX * sumY) / denominator;

                    // To convert to weekly percentage rate:
                    // We need an initial 1RM for the period to calculate percentage against.
                    // Use the 1RM of the first data point in the considered period.
                    const initial1RMOfPeriod = dataPoints[0].y;
                    if (initial1RMOfPeriod === 0) return 0; // Avoid division by zero

                    const weeklyRate = (slopePerDay * 7 / initial1RMOfPeriod) * 100;

                    return parseFloat(weeklyRate.toFixed(2)); // Percentage per week
                },

                async calculateProgressMetrics(state, daysConsidered = 30) {
                    if (!state.history || state.history.length === 0) {
                        // Not enough data to calculate meaningful metrics yet
                        // Keep default trainingMetrics or reset to baseline
                        state.trainingMetrics = { volumeLoad: 0, intensityIndex: 0, fatigueLevel: 0, recoveryScore: 100, performanceIndex: 100 };
                        return;
                    }

                    const now = Date.now();
                    const startTimeOfPeriod = now - (daysConsidered * 24 * 60 * 60 * 1000);
                    const recentHistory = state.history.filter(session => session.startTime >= startTimeOfPeriod);

                    // 1. Total Volume Load Last X Days
                    let totalVolumeLoad = 0;
                    recentHistory.forEach(session => {
                        totalVolumeLoad += session.summary?.totalVolume || 0;
                    });
                    state.trainingMetrics.volumeLoad = parseFloat(totalVolumeLoad.toFixed(0));

                    // 2. Average Intensity Index
                    let sumOfRelativeIntensities = 0;
                    let countOfRelativeIntensities = 0;
                    let sumOfRPEs = 0;
                    let countOfRPEs = 0;

                    for (const session of recentHistory) {
                        for (const exSession of session.exercises) {
                            const coreEx = state.exercises.get(exSession.exerciseId);
                            if (coreEx && coreEx.metrics.personalRecord && coreEx.metrics.personalRecord > 0) {
                                exSession.completedSets.forEach(set => {
                                    if (set.weight > 0 && coreEx.metrics.personalRecord > 0) { // only if actual weight lifted
                                        sumOfRelativeIntensities += (set.weight / coreEx.metrics.personalRecord);
                                        countOfRelativeIntensities++;
                                    }
                                });
                            }
                            exSession.completedSets.forEach(set => {
                                if (set.rpe) {
                                    sumOfRPEs += set.rpe;
                                    countOfRPEs++;
                                }
                            });
                        }
                    }
                    if (countOfRelativeIntensities > 0) {
                        state.trainingMetrics.intensityIndex = parseFloat(((sumOfRelativeIntensities / countOfRelativeIntensities) * 100).toFixed(1));
                    } else if (countOfRPEs > 0) { // Fallback to RPE-based if PRs are not set for intensity calc
                        state.trainingMetrics.intensityIndex = parseFloat(((sumOfRPEs / countOfRPEs) * 10).toFixed(1)); // Scale RPE avg to ~0-100
                    } else {
                        state.trainingMetrics.intensityIndex = 50; // Default if no data
                    }


                    // 3. Calculate Fatigue Level (Heuristic)
                    // More recent, high RPE, high volume workouts contribute more to fatigue.
                    let fatigueScore = 0;
                    const sevenDaysAgo = now - (7 * 24 * 60 * 60 * 1000);
                    const workoutsLast7Days = state.history.filter(s => s.startTime >= sevenDaysAgo);

                    workoutsLast7Days.forEach(session => {
                        const daysOld = (now - session.startTime) / (24 * 60 * 60 * 1000);
                        const recencyFactor = Math.max(0.1, 1 - (daysOld / 7)); // Closer to 1 if recent

                        let sessionFatigue = 0;
                        if (session.summary?.avgRPE && session.summary.avgRPE >= 8) sessionFatigue += 20;
                        else if (session.summary?.avgRPE && session.summary.avgRPE >= 6) sessionFatigue += 10;

                        if (session.summary?.totalVolume && session.summary.totalVolume > 7000) sessionFatigue += 15; // High volume
                        else if (session.summary?.totalVolume && session.summary.totalVolume > 4000) sessionFatigue += 7; // Moderate volume

                        fatigueScore += sessionFatigue * recencyFactor;
                    });
                    state.trainingMetrics.fatigueLevel = Math.min(100, Math.max(0, parseFloat(fatigueScore.toFixed(0))));

                    // 4. Calculate Recovery Score
                    state.trainingMetrics.recoveryScore = 100 - state.trainingMetrics.fatigueLevel;

                    // 5. Calculate Performance Index (Heuristic)
                    let avgProgressRate = 0;
                    let keyExercisesCount = 0;
                    const keyExerciseIds = Array.from(state.exercises.values())
                        .filter(ex => ex.type === 'compound' && ex.metrics.performanceHistory.length > 5) // Compound exercises with some history
                        .slice(0, 3) // Take up to 3
                        .map(ex => ex.id);

                    if (keyExerciseIds.length > 0) {
                        keyExerciseIds.forEach(exId => {
                            const coreEx = state.exercises.get(exId);
                            if (coreEx) {
                                avgProgressRate += this.calculateProgressRate(coreEx.metrics.performanceHistory, 4); // 4 weeks
                                keyExercisesCount++;
                            }
                        });
                        if (keyExercisesCount > 0) avgProgressRate /= keyExercisesCount;
                    }

                    // Normalize progressRate (e.g., 2% weekly is good = 1.0, 0% = 0.5, negative = <0.5)
                    // Max of 5% weekly progress for score, min of -5%
                    const normalizedProgress = Math.max(0, Math.min(1, (avgProgressRate + 5) / 10)); // Scale -5% to 5% into 0 to 1

                    const consistencyScore = (state.user.stats?.currentStreak || 0) > 7 ? 1.0 : (state.user.stats?.currentStreak || 0) / 7; // Max out at 1 after 7 days streak

                    let performanceIndex = (normalizedProgress * 50) + (state.trainingMetrics.recoveryScore * 0.3) + (consistencyScore * 20);
                    state.trainingMetrics.performanceIndex = Math.min(100, Math.max(0, parseFloat(performanceIndex.toFixed(0))));

                    // console.log("Updated Training Metrics:", state.trainingMetrics);
                    // Caller should handle saving: await App.storage.save(state);
                },

                generateProgressReport(state) {
                    console.log("generateProgressReport called. Implementation pending.");
                    // This would analyze trends, PRs, volume changes etc.
                    // and generate textual summaries and recommendations.
                    const report = {
                        summary: "Dein Fortschrittsbericht wird demn√§chst hier verf√ºgbar sein.",
                        keyObservations: [
                            `Aktueller Performance Index: ${state.trainingMetrics.performanceIndex}/100`,
                            `M√ºdigkeitslevel: ${state.trainingMetrics.fatigueLevel}/100`,
                            `Erholungsscore: ${state.trainingMetrics.recoveryScore}/100`,
                        ],
                        recommendations: [
                            "Achte weiterhin auf konsistentes Training und Regeneration.",
                            "Analysiere deine √úbungsfortschritte, um Plateaus fr√ºhzeitig zu erkennen."
                        ],
                        chartsData: [] // Could include data for mini-charts in the report
                    };

                    // Example: Add a PR change observation
                    // const benchPress = Array.from(state.exercises.values()).find(ex => ex.name.toLowerCase().includes("bankdr√ºcken"));
                    // if (benchPress) {
                    //     const progressRate = this.calculateProgressRate(benchPress.metrics.performanceHistory, 4);
                    //     report.keyObservations.push(`Bankdr√ºcken Fortschritt (4 Wochen): ${progressRate}%/Woche.`);
                    // }
                    return report;
                },

                identifyAchievements(state) {
                    console.log("identifyAchievements called.");
                    const newAchievements = [];
                    const { achievements, user, history, exercises } = state;

                    if (!user.stats) return []; // No stats, no achievements yet

                    // First Workout
                    if (user.stats.totalWorkouts >= 1 && !achievements.has('first_workout_done')) {
                        achievements.add('first_workout_done');
                        const ach = { id: 'first_workout_done', name: 'Erstes Training absolviert!', description: "Du hast dein erstes Training abgeschlossen. Weiter so!", date: new Date().toISOString() };
                        newAchievements.push(ach);
                        App.ui.showToast(`üèÜ Errungenschaft: ${ach.name}`, "success");
                    }

                    // Consistent Trainer (e.g., 7-day streak)
                    if (user.stats.currentStreak >= 7 && !achievements.has('consistent_week')) {
                        achievements.add('consistent_week');
                        const ach = { id: 'consistent_week', name: 'Konstante Woche', description: "Eine ganze Woche Training am St√ºck! Super!", date: new Date().toISOString() };
                        newAchievements.push(ach);
                        App.ui.showToast(`üèÜ Errungenschaft: ${ach.name}`, "success");
                    }

                    // Volume Milestone (e.g., 100,000 kg total volume)
                    if (user.stats.totalVolume >= 100000 && !achievements.has('volume_100k')) {
                        achievements.add('volume_100k');
                        const ach = { id: 'volume_100k', name: 'Volumen-Meister (100t kg)', description: "√úber 100.000kg Gesamtvolumen bewegt!", date: new Date().toISOString() };
                        newAchievements.push(ach);
                        App.ui.showToast(`üèÜ Errungenschaft: ${ach.name}`, "success");
                    }

                    // TODO: Add more achievement checks:
                    // - Specific PRs on key lifts (e.g., Bench 100kg)
                    // - Number of plans created
                    // - X workouts completed
                    // - Using specific features (e.g., VBT metrics if they were real)

                    return newAchievements; // Return array of newly unlocked achievements
                }
            },

            /**
             * Namespace for utility functions.
             */
            utils: {
                generateId(prefix) {
                    return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                }
            }
        },
        
        // ===================================================================
        // 4. UI-DRIVING ACTIONS & EVENT HANDLERS
        // ===================================================================

        saveSettings() {
            this.state.user.name = document.getElementById('userName').value;
            this.state.user.level = document.getElementById('userLevel').value;
            this.ui.showToast("‚úÖ", "Einstellungen gespeichert!", "success");
            this.storage.save(this.state);
            this.render();
        },
    
        async resetData() {
            if (confirm("Wirklich alle Daten l√∂schen? Dies kann nicht r√ºckg√§ngig gemacht werden.")) {
                await this.db.clear('settings');
                await this.db.clear('exercises');
                await this.db.clear('plans');
                await this.db.clear('history');
                this.state = await this.storage.getInitialStateAndPersist();
                this.render();
            }
        },
    
        // ===================================================================
        // 5. UI RENDERING & DOM MANIPULATION
        // ===================================================================
        
        ui: {
            init() {
                // Populate static elements that don't change often
                document.getElementById('main-nav').innerHTML = [
                    { view: 'dashboard', label: 'Dashboard' },
                    { view: 'plans', label: 'Pl√§ne' },
                    { view: 'training', label: 'Training' },
                    { view: 'exercises', label: '√úbungen' },
                    { view: 'analytics', label: 'Analyse' },
                    { view: 'settings', label: 'Einstellungen' }
                ].map(item => `<button class="nav-tab" data-action="navigate" data-view="${item.view}">${item.label}</button>`).join('');
            },
    
            renderTheme() {
                document.documentElement.dataset.theme = App.state.ui.theme;
                document.getElementById('themeToggle').textContent = App.state.ui.theme === 'light' ? 'üåô' : '‚òÄÔ∏è';
            },
            
            renderNav() {
                document.querySelectorAll('#main-nav .nav-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.view === App.state.ui.currentView);
                });
            },
            
            renderDashboard() {
                const { user, history, plans, trainingMetrics } = App.state;
                const userStats = user.stats || { totalWorkouts: 0, totalVolume: 0, currentStreak: 0 }; // Fallback for safety
                const displayMetrics = trainingMetrics || { performanceIndex: 0, recoveryScore: 0, fatigueLevel: 0 }; // Fallback

                const lastWo = history[history.length - 1];
                let suggestionHTML = `<div class="suggestion-card"><div class="suggestion-icon">üí°</div><div><h3>Bereit f√ºrs Training!</h3><p>W√§hle einen Plan, um loszulegen und deine Fitness-Reise zu starten.</p></div></div>`;
                if(lastWo && (Date.now() - lastWo.startTime) / 36e5 < 24) {
                    suggestionHTML = `<div class="suggestion-card" style="background: linear-gradient(135deg, #1d4ed8, #3b82f6);"><div class="suggestion-icon">üßò</div><div><h3>Erholungstag!</h3><p>Dein letztes Training ist weniger als 24h her. G√∂nn dir eine Pause f√ºr optimale Regeneration.</p></div></div>`;
                }

                return `
                    <section id="dashboard" class="section active">
                        <h1>Willkommen, ${user.name}!</h1>
                        <div class="mode-selector">
                            ${Object.entries({ beginner: 'üå± Anf√§nger', intermediate: 'üéØ Sportlich', expert: 'üöÄ Experte'}).map(([key, val]) =>
                                `<div class="mode-card ${user.level === key ? 'selected' : ''}" data-action="set-user-level" data-level="${key}">
                                    <div class="mode-icon">${val.split(' ')[0]}</div><h3>${val.split(' ')[1]}</h3>
                                </div>`
                            ).join('')}
                        </div>
                        ${suggestionHTML}
                        <h2>Deine aktuellen Metriken</h2>
                        <div class="grid">
                            <div class="stat-card"><div class="stat-value">${userStats.totalWorkouts}</div><div class="stat-label">Workouts Gesamt</div></div>
                            <div class="stat-card"><div class="stat-value">${(userStats.totalVolume || 0).toLocaleString()} kg</div><div class="stat-label">Gesamtvolumen</div></div>
                            <div class="stat-card"><div class="stat-value">${userStats.currentStreak} Tage</div><div class="stat-label">Aktuelle Serie</div></div>
                            <div class="stat-card"><div class="stat-value">${displayMetrics.performanceIndex} / 100</div><div class="stat-label">Performance Index</div></div>
                            <div class="stat-card"><div class="stat-value">${displayMetrics.recoveryScore} / 100</div><div class="stat-label">Erholungsscore</div></div>
                            <div class="stat-card"><div class="stat-value">${displayMetrics.fatigueLevel} / 100</div><div class="stat-label">M√ºdigkeitslevel</div></div>
                        </div>

                        <div class="grid" style="grid-template-columns: 2fr 1fr; margin-top: 2rem;">
                            <div>
                                <h2>Letzte Trainingseinheiten</h2>
                                <div class="card">${history.length > 0 ? `<ul>${[...history].reverse().slice(0,5).map(wo => `<li><strong>${new Date(wo.startTime).toLocaleDateString()}:</strong> ${plans.get(wo.planId)?.name || 'Gel√∂schter Plan'}</li>`).join('')}</ul>` : '<p>Keine Eintr√§ge.</p>'}</div>
                            </div>
                            <div>
                                <h2>Hydration</h2>
                                <div class="hydration-tracker">
                                    <h3>Heute:</h3>
                                    ${Array.from({length: user.hydration.goal}, (_, i) => 
                                        `<div class="water-glass" data-action="update-hydration" data-amount="${i < user.hydration.current ? -1 : 1}">
                                            <div class="water-fill" style="height:${i < user.hydration.current ? '100%' : '0%'}"></div>
                                        </div>`
                                    ).join('')}
                                    <span>${user.hydration.current}/${user.hydration.goal}</span>
                                </div>
                            </div>
                        </div>
                        <h2>Schnellstart</h2>
                        <div class="grid">
                            ${Array.from(plans.values()).map(p => `<button class="btn btn-primary" data-action="start-session" data-plan-id="${p.id}">Start: ${p.name}</button>`).join('') || '<p>Erstelle einen Plan, um hier Schnellstarts zu sehen.</p>'}
                        </div>
                    </section>
                `;
            },
            
            renderExercises() {
                return `
                    <section id="exercises" class="section active">
                        <h1>√úbungsverwaltung</h1>
                        <div class="exercise-container">
                            <div class="exercise-list">
                                <h2>Alle √úbungen</h2>
                                <button class="btn btn-primary" data-action="show-exercise-form" style="margin-bottom: 1rem;">+ Neue √úbung</button>
                                <div class="grid">
                                    ${Array.from(App.state.exercises.values()).map(ex => `
                                        <div class="card" draggable="true" data-drag-id="${ex.id}">
                                            <h3>${ex.name}</h3>
                                            <p>Muskelgruppe: ${ex.muscleGroup}</p>
                                            <p>Typ: ${ex.type}</p>
                                            <!-- Weitere Details oder Bearbeiten-Button hier m√∂glich -->
                                        </div>`).join('') || '<p>Keine √úbungen erstellt.</p>'}
                                </div>
                            </div>
                             <div class="exercise-sets-list" style="margin-top: 2rem;">
                                <h2>√úbungssets</h2>
                                <button class="btn btn-primary" data-action="show-exercise-set-form" style="margin-bottom: 1rem;">+ Neues √úbungsset</button>
                                <div class="grid">
                                     ${Array.from(App.state.exerciseSets.values()).map(set => `
                                        <div class="card">
                                            <h3>${set.name}</h3>
                                            <p>${set.exercises.length} √úbung(en)</p>
                                            <!-- Button zum Bearbeiten/Ansehen des Sets hier m√∂glich -->
                                        </div>`).join('') || '<p>Keine √úbungssets erstellt.</p>'}
                                </div>
                            </div>
                        </div>
                    </section>
                `;
            },
            
            renderPlans() {
                 return `
                    <section id="plans" class="section active">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <h1>Trainingspl√§ne</h1>
                            <button class="btn btn-primary" data-action="show-plan-form">+ Neuer Trainingsplan</button>
                        </div>
                        <div class="grid">
                            ${App.state.plans.size > 0 ? Array.from(App.state.plans.values()).map(p => `
                                <div class="card">
                                    <h3>${p.name}</h3>
                                    <p>${p.description || 'Keine Beschreibung.'}</p>
                                    <p><strong>${p.exercises.length} √úbungen</strong> | Typ: ${p.type || 'N/A'}</p>
                                    <p><small>Periodisierung: ${p.periodization?.type || 'Keine'} | ${p.periodization?.cycleLength || 0} Wochen Zyklus</small></p>
                                    <div style="display:flex; gap:0.5rem; margin-top:1rem;">
                                        <button class="btn btn-primary" data-action="start-session" data-plan-id="${p.id}">Starten</button>
                                        <button class="btn" style="background:var(--text-secondary); color:white;" data-action="show-plan-editor" data-plan-id="${p.id}">Bearbeiten</button>
                                    </div>
                                </div>`).join('') : '<p>Keine Pl√§ne erstellt. Klicke auf "+ Neuer Trainingsplan", um loszulegen!</p>'}
                        </div>
                    </section>`;
            },
            
            renderTraining() {
                const session = App.state.session;
                if (!session) {
                    let html = `
                        <section id="training" class="section active">
                            <h1>Training</h1>`;

                    const userPlans = Array.from(App.state.plans.values()).filter(p => p.id !== 'quick_set_runtime');
                    const plansExist = userPlans.length > 0;

                    if (plansExist) {
                        html += `<h2>W√§hle einen Plan zum Starten</h2>
                                 <div class="grid">
                                   ${userPlans.map(p => `<button class="btn btn-primary" style="height:80px;" data-action="start-session" data-plan-id="${p.id}">${p.name}</button>`).join('')}
                                 </div>`;
                    }

                    if (App.state.quickSet && App.state.quickSet.length > 0) {
                        html += `<div class="card" style="margin-top: 2rem;">
                                    <h3>Schnelles Set (${App.state.quickSet.length} √úbungen)</h3>
                                    <ul style="list-style-position: inside; padding-left: 1rem; margin-bottom:1rem;">
                                        ${App.state.quickSet.map(exId => `<li>${App.state.exercises.get(exId)?.name || 'Unbekannte √úbung'}</li>`).join('')}
                                    </ul>
                                    <button class="btn btn-secondary" data-action="start-quick-set">Schnelles Set starten</button>
                                 </div>`;
                    }

                    if (!plansExist && (!App.state.quickSet || App.state.quickSet.length === 0)) {
                         html += '<p style="margin-top:1rem;">Erstelle einen Plan oder f√ºge √úbungen zu einem schnellen Set hinzu (auf der √úbungsseite), um mit dem Training zu beginnen.</p>';
                    }

                    html += `</section>`;
                    return html;
                }
                
                const currentSessionEx = session.exercises[session.currentExIndex];
                const coreExData = App.state.exercises.get(currentSessionEx.exerciseId);
                const lastSet = currentSessionEx.completedSets[currentSessionEx.completedSets.length - 1];
                
                let setRowsHtml = '';
                for (let i = 0; i < currentSessionEx.plannedSets; i++) {
                    const set = currentSessionEx.completedSets[i];
                    const isCurrentSet = i === currentSessionEx.completedSets.length;
                    setRowsHtml += `<div class="exercise-set ${set ? 'completed' : (isCurrentSet ? 'current' : '')}">
                                        <div class="set-number">${i+1}</div>
                                        <input type="number" step="0.25" placeholder="kg" value="${set ? set.weight : currentSessionEx.targetWeight}" ${set ? 'disabled' : ''}>
                                        <input type="number" placeholder="Wdh" value="${set?.reps || ''}" ${set ? 'disabled' : ''}>
                                        <input type="number" min="1" max="10" step="0.5" placeholder="RPE" value="${set?.rpe || ''}" ${set ? 'disabled' : ''}>
                                        ${set ? `<span class="btn" style="background:var(--secondary); color:white; padding: 0.5rem; font-size: 0.8rem; cursor:default;">${(set.volume || 0).toFixed(0)}kg</span>` : (isCurrentSet ? `<button class="btn btn-secondary" style="padding:0.5rem" data-action="perform-set" data-ex-index="${session.currentExIndex}" data-set-index="${i}">‚úì</button>` : `<button class="btn btn-secondary" style="padding:0.5rem" disabled>‚úì</button>`)}
                                    </div>`;
                }

                return `
                    <section id="training" class="section active">
                        <div class="session-container">
                            <h2>${coreExData.name} <span style="font-weight:normal;color:var(--text-secondary)">(${session.currentExIndex+1}/${session.exercises.length})</span></h2>
                            <p><strong>Ziel:</strong> ${currentSessionEx.plannedSets} S√§tze √† ${currentSessionEx.targetReps} Wdh. | <strong>Pause:</strong> ${currentSessionEx.targetRest}s</p>
                            <p><em>Notizen zur √úbung: ${coreExData.notes || "Keine Notizen"}</em></p>
                            <div>
                                ${setRowsHtml}
                            </div>
                            <div style="margin-top: 1rem;">
                                <h3>Intensit√§t (RPE des letzten Satzes)</h3>
                                <div class="intensity-meter">
                                    ${Array.from({length: 10}, (_, i) => {
                                        let activeClass = '';
                                        if (lastSet && (i + 1) <= lastSet.rpe) {
                                            if (lastSet.rpe > 8) activeClass = 'active-high';
                                            else if (lastSet.rpe > 6) activeClass = 'active-mid';
                                            else activeClass = 'active-low';
                                        }
                                        return `<div class="intensity-bar ${activeClass}" style="height: ${20 + (i+1)*2}px; background:${activeClass ? `var(--${activeClass.split('-')[1]})` : ''};"></div>`;
                                    }).join('')}
                                </div>
                            </div>
                            <div style="margin-top: 1.5rem; display: flex; justify-content: space-between;">
                                <button class="btn btn-danger" data-action="finish-session">Training beenden</button>
                                <button class="btn btn-primary" ${session.currentExIndex >= session.exercises.length -1 && currentSessionEx.completedSets.length >= currentSessionEx.plannedSets ? 'disabled' : ''} data-action="next-exercise">N√§chste √úbung ‚Üí</button>
                            </div>
                        </div>
                    </section>`;
            },

            renderAnalyticsShell() {
                return `
                    <section id="analytics" class="section active">
                        <h1>Trainingsanalysen</h1>
                        <div id="analytics-content">
                            ${App.state.history.length < 1 ? "<p>Noch keine Daten vorhanden. Absolviere ein Training, um deine Fortschritte zu sehen.</p>" : `
                                <div class="grid">
                                    <div class="chart-container card"><canvas id="volumeChart"></canvas></div>
                                    <div class="chart-container card"><canvas id="strengthChart"></canvas></div>
                                </div>
                                <div class="grid" style="grid-template-columns: 2fr 1fr;">
                                    <div>
                                        <h2>Trainings-Heatmap (Letztes Halbjahr)</h2>
                                        <div class="heatmap-container card" id="trainingHeatmap"></div>
                                    </div>
                                    <div>
                                        <h2>Muskel-Fokus (Letzte 10 Workouts)</h2>
                                        <div class="muscle-map card" id="muscle-map"></div>
                                    </div>
                                </div>
                                <h2>Errungenschaften</h2>
                                <div id="achievements-container" class="grid"></div>
                            `}
                        </div>
                    </section>`;
            },
            
            renderAnalyticsCharts() {
                const { history, exercises, achievements } = App.state; // Added achievements
                if (history.length < 1 && (!achievements || achievements.size === 0)) { // Adjusted condition
                     // analytics-content might not be fully empty if shell is complex, target specific part if needed
                    const ac = document.getElementById('analytics-content');
                    if(ac && !ac.querySelector('.chart-container') && !ac.querySelector('.achievement')) { // Avoid overwriting if content is already there
                        ac.innerHTML = "<p>Noch keine Daten vorhanden. Absolviere ein Training oder schalte Errungenschaften frei, um deine Fortschritte zu sehen.</p>";
                    }
                    return;
                }


                // Volume Chart
                const weeklyVolume = App.logic.analytics.getWeeklyVolume(history);
                this.createOrUpdateChart('volumeChart', 'bar', {
                    labels: weeklyVolume.map(w => w[0]),
                    datasets: [{ label: 'W√∂chentliches Volumen (kg)', data: weeklyVolume.map(w => w[1]), backgroundColor: 'rgba(59, 130, 246, 0.7)' }]
                });

                // Strength Chart
                const strengthProgress = App.logic.analytics.getStrengthProgress(exercises);
                if (strengthProgress) {
                    this.createOrUpdateChart('strengthChart', 'line', {
                        datasets: [{ label: strengthProgress.label, data: strengthProgress.data, borderColor: 'rgba(239, 68, 68, 0.8)', tension: 0.1, pointRadius: 4, pointBackgroundColor: 'rgba(239, 68, 68, 1)' }]
                    }, { scales: { x: { type: 'time', time: { unit: 'week' } } } });
                }

                // Heatmap
                const heatmapContainer = document.getElementById('trainingHeatmap');
                if(heatmapContainer) {
                    heatmapContainer.innerHTML = ''; // Clear previous
                    const heatmapData = App.logic.analytics.getHeatmapData(history);
                    const startDate = new Date();
                    startDate.setDate(startDate.getDate() - (26*7) + 1); // Approx 6 months back
                    for(let i=0; i<26*7; i++) {
                        const d = new Date(startDate);
                        d.setDate(d.getDate() + i);
                        const dateString = d.toISOString().split('T')[0];
                        const intensity = Math.min(3, heatmapData[dateString] || 0);
                        heatmapContainer.innerHTML += `<div class="heatmap-cell" data-intensity="${intensity}" title="${d.toLocaleDateString()}: ${heatmapData[dateString] || 0} Workouts"></div>`;
                    }
                }
                
                // Muscle Focus
                const muscleMapContainer = document.getElementById('muscle-map');
                if(muscleMapContainer) {
                    muscleMapContainer.innerHTML = ''; // Clear previous
                    const muscleFocus = App.logic.analytics.getMuscleFocus(history, exercises);
                    const muscleGroups = {chest: 'Brust', back: 'R√ºcken', legs: 'Beine', shoulders: 'Schultern', triceps: 'Trizeps', biceps: 'Bizeps', core: 'Core'};
                    muscleMapContainer.innerHTML = Object.entries(muscleGroups).map(([key, name]) =>
                        `<div class="muscle-group ${muscleFocus[key] ? 'worked' : ''}">${name}</div>`
                    ).join('');
                }
                
                // Achievements
                const achievementsContainer = document.getElementById('achievements-container');
                if(achievementsContainer) {
                    achievementsContainer.innerHTML = ''; // Clear previous
                    const achievementDetails = {
                        'first_workout_done': { name: 'Erstes Training absolviert!', description: "Du hast dein erstes Training abgeschlossen. Weiter so!", icon: 'üéâ' },
                        'consistent_week': { name: 'Konstante Woche!', description: '7 Tage am St√ºck trainiert!', icon: 'üî•' },
                        'volume_100k': { name: 'Volumen-Meister (100t kg)!', description: '√úber 100.000kg Gesamtvolumen bewegt!', icon: 'üí™' },
                        'new_pr': { name: 'Pers√∂nlicher Rekord!', description: 'Fantastisch! Du hast einen neuen pers√∂nlichen Rekord aufgestellt!', icon: 'üèÜ' }
                    };

                    if (App.state.achievements && App.state.achievements.size > 0) {
                        App.state.achievements.forEach(achId => {
                            const details = achievementDetails[achId];
                            if (details) {
                                achievementsContainer.innerHTML += `
                                <div class="achievement">
                                    <div class="achievement-icon">${details.icon}</div>
                                    <div>
                                        <h3>${details.name}</h3>
                                        <p>${details.description}</p>
                                    </div>
                                </div>`;
                            }
                        });
                    } else {
                        achievementsContainer.innerHTML = '<p>Noch keine Errungenschaften freigeschaltet. Bleib dran!</p>';
                    }
                }
            },
            
            renderSettings() {
                const userLevels = { beginner: "Anf√§nger", intermediate: "Sportlich", expert: "Experte" };
                return `
                    <section id="settings" class="section active">
                        <h1>Einstellungen</h1>
                        <div class="grid">
                            <div class="card">
                                <h3>Profil</h3>
                                <div class="form-group"><label for="userName">Benutzername</label><input type="text" id="userName" value="${App.state.user.name}"></div>
                                <div class="form-group"><label>Trainingslevel</label><select id="userLevel">${Object.entries(userLevels).map(([k,v])=>`<option value="${k}" ${App.state.user.level === k ? 'selected' : ''}>${v}</option>`).join('')}</select></div>
                                <button class="btn btn-primary" data-action="save-settings">Speichern</button>
                            </div>
                            <div class="card">
                                <h3>Datenmanagement</h3>
                                <div class="grid" style="grid-template-columns: 1fr 1fr;">
                                    <button class="btn btn-secondary" data-action="export-data">Daten exportieren</button>
                                    <button class="btn" style="background:#555;color:white" data-action="import-data">Daten importieren</button>
                                    <button class="btn btn-danger" data-action="reset-data">Alle Daten l√∂schen</button>
                                </div>
                            </div>
                        </div>

                        <div class="card" style="margin-top: 2rem;">
                            <h3>Ger√§teverwaltung</h3>
                            <button class="btn btn-primary" data-action="show-equipment-form" style="margin-bottom: 1rem;">+ Neues Ger√§t hinzuf√ºgen</button>
                            <div id="equipmentListContainer">
                                ${Array.from(App.state.equipment.values()).map(item => `
                                    <div class="equipment-item" data-id="${item.id}" style="padding: 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; margin-bottom: 0.5rem; background: var(--surface-bg); display: flex; justify-content: space-between; align-items: center;">
                                        <div>
                                            <h4>${item.name}</h4>
                                            <p style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 0;">${item.description || 'Keine Beschreibung.'}</p>
                                        </div>
                                        <div style="display: flex; gap: 0.5rem;">
                                            <button class="btn btn-secondary" data-action="edit-equipment" data-id="${item.id}" style="padding: 0.4rem 0.8rem; font-size: 0.85rem;">Bearbeiten</button>
                                            <button class="btn btn-danger" data-action="delete-equipment" data-id="${item.id}" style="padding: 0.4rem 0.8rem; font-size: 0.85rem;">L√∂schen</button>
                                        </div>
                                    </div>
                                `).join('') || '<p>Noch keine Ger√§te hinzugef√ºgt.</p>'}
                            </div>
                        </div>
                    </section>`;
            },
            
            // --- UI Helper & Action Functions ---

            handleSetCompletion(actionButton) {
                const setRow = actionButton.closest('.exercise-set');
                if (!setRow) {
                    this.showToast("‚ùå", "Fehler: Set-Reihe nicht gefunden.", "error");
                    return;
                }
                const inputs = setRow.querySelectorAll('input[type="number"]'); // More specific selector
                const weightInput = inputs[0];
                const repsInput = inputs[1];
                const rpeInput = inputs[2];

                const weight = parseFloat(weightInput.value);
                const reps = parseInt(repsInput.value, 10);
                const rpe = parseFloat(rpeInput.value);

                if (isNaN(weight) || weight < 0 || isNaN(reps) || reps <= 0 || isNaN(rpe) || rpe < 1 || rpe > 10) {
                    this.showToast("‚ùå", "Ung√ºltige Eingabe f√ºr Gewicht, Wdh. oder RPE.", "error");
                    // Potentially add more specific error messages per field
                    if (isNaN(weight) || weight < 0) weightInput.style.borderColor = 'var(--danger)'; else weightInput.style.borderColor = 'var(--border)';
                    if (isNaN(reps) || reps <= 0) repsInput.style.borderColor = 'var(--danger)'; else repsInput.style.borderColor = 'var(--border)';
                    if (isNaN(rpe) || rpe < 1 || rpe > 10) rpeInput.style.borderColor = 'var(--danger)'; else rpeInput.style.borderColor = 'var(--border)';
                    return;
                }
                // Reset border colors on valid submission attempt
                weightInput.style.borderColor = 'var(--border)';
                repsInput.style.borderColor = 'var(--border)';
                rpeInput.style.borderColor = 'var(--border)';

                const { exIndex, setIndex } = actionButton.dataset;
                actionButton.disabled = true; // Disable button to prevent double submission

                // This calls the synchronous version of performSet currently in App.logic.session
                // That version internally calls App.ui.startRestTimer and App.render
                App.logic.session.performSet(parseInt(exIndex), parseInt(setIndex), { weight, reps, rpe });
                // If App.logic.session.performSet became async and returned {success, calculatedRest},
                // then the logic here would be:
                // const result = await App.logic.session.performSet(parseInt(exIndex), parseInt(setIndex), { weight, reps, rpe }, App.state);
                // if (result.success) {
                //     this.startRestTimer(result.calculatedRest);
                //     App.render();
                // } else {
                //     this.showToast(result.error || "Fehler beim Speichern des Satzes.", "error");
                //     actionButton.disabled = false; // Re-enable button on error
                // }
            },

            showExerciseForm() {
                const muscleGroups = {chest: 'Brust', back: 'R√ºcken', legs: 'Beine', shoulders: 'Schultern', triceps: 'Trizeps', biceps: 'Bizeps', core: 'Core', fullbody: 'Ganzk√∂rper', cardio: 'Cardio'};
                const exerciseTypes = {compound: 'Verbund√ºbung', isolation: 'Isolations√ºbung', cardio: 'Cardio√ºbung'};
                const equipmentTypes = {barbell: 'Langhantel', dumbbell: 'Kurzhantel', machine: 'Maschine', cable: 'Kabelzug', bodyweight: 'K√∂rpergewicht', kettlebell: 'Kettlebell', band: 'Widerstandsband', cardio_machine: 'Cardioger√§t', none: 'Keine'};

                document.getElementById('formModalContent').innerHTML = `
                    <h2>Neue √úbung erstellen / Bearbeiten</h2>
                    <form data-form="add-exercise">
                        <div class="form-group"><label for="ex-name">Name</label><input type="text" id="ex-name" name="name" required></div>

                        <div class="grid" style="grid-template-columns: 1fr 1fr; gap: 1rem;">
                            <div class="form-group">
                                <label for="ex-muscleGroup">Muskelgruppe</label>
                                <select id="ex-muscleGroup" name="muscleGroup">${Object.entries(muscleGroups).map(([k,v])=>`<option value="${k}">${v}</option>`).join('')}</select>
                            </div>
                            <div class="form-group">
                                <label for="ex-type">Typ</label>
                                <select id="ex-type" name="type">${Object.entries(exerciseTypes).map(([k,v])=>`<option value="${k}">${v}</option>`).join('')}</select>
                            </div>
                        </div>

                        <div class="form-group">
                            <label for="ex-equipment">Ger√§t</label>
                            <select id="ex-equipment" name="equipment">${Object.entries(equipmentTypes).map(([k,v])=>`<option value="${k}">${v}</option>`).join('')}</select>
                        </div>

                        <h3>Optionale Details</h3>
                        <div class="grid" style="grid-template-columns: 1fr 1fr; gap: 1rem;">
                            <div class="form-group"><label for="ex-settings_seat">Sitzeinstellung</label><input type="text" id="ex-settings_seat" name="settings_seat"></div>
                            <div class="form-group"><label for="ex-settings_backrest">Lehneneinstellung</label><input type="text" id="ex-settings_backrest" name="settings_backrest"></div>
                            <div class="form-group"><label for="ex-rom">Bewegungsumfang (ROM)</label><input type="text" id="ex-rom" name="biomechanics_rangeOfMotion" placeholder="z.B. Voll, Partiell"></div>
                            <div class="form-group"><label for="ex-tempo">Tempo</label><input type="text" id="ex-tempo" name="biomechanics_tempo" placeholder="z.B. 2-0-2-0"></div>
                        </div>
                         <div class="form-group"><label for="ex-stabilization">Stabilisierungsbedarf (0-1)</label><input type="number" id="ex-stabilization" name="biomechanics_stabilizationDemand" step="0.1" min="0" max="1" placeholder="0.5"></div>

                        <div style="display: flex; gap: 0.5rem; justify-content: flex-end; margin-top: 1rem;">
                            <button type="button" class="btn btn-secondary" data-action="close-modal" data-modal-id="formModal">Abbrechen</button>
                            <button type="submit" class="btn btn-primary">√úbung speichern</button>
                        </div>
                    </form>`;
                this.showModal('formModal');
            },

            showPlanForm() {
                const planTypes = {custom: 'Benutzerdefiniert', fullbody: 'Ganzk√∂rper', push: 'Push', pull: 'Pull', legs: 'Legs', upper_lower: 'Ober-/Unterk√∂rper'};
                const periodizationTypes = {linear: 'Linear', undulating: 'Undulierend', block: 'Block', none: 'Keine'};
                document.getElementById('formModalContent').innerHTML = `
                    <h2>Neuen Plan erstellen</h2>
                    <form data-form="add-plan">
                        <div class="form-group"><label for="plan-name">Name des Plans</label><input type="text" id="plan-name" name="name" required></div>
                        <div class="form-group"><label for="plan-desc">Beschreibung</label><textarea id="plan-desc" name="description"></textarea></div>

                        <div class="grid" style="grid-template-columns: 1fr 1fr; gap: 1rem;">
                            <div class="form-group">
                                <label for="plan-type">Plantyp</label>
                                <select id="plan-type" name="type">${Object.entries(planTypes).map(([k,v])=>`<option value="${k}">${v}</option>`).join('')}</select>
                            </div>
                            <div class="form-group">
                                <label for="plan-periodizationType">Periodisierung</label>
                                <select id="plan-periodizationType" name="periodizationType">${Object.entries(periodizationTypes).map(([k,v])=>`<option value="${k}">${v}</option>`).join('')}</select>
                            </div>
                        </div>
                        <div class="form-group"><label for="plan-cycleLength">Zyklusl√§nge (Wochen)</label><input type="number" id="plan-cycleLength" name="cycleLength" value="4" min="1"></div>

                        <div style="display: flex; gap: 0.5rem; justify-content: flex-end; margin-top: 1rem;">
                            <button type="button" class="btn btn-secondary" data-action="close-modal" data-modal-id="formModal">Abbrechen</button>
                            <button type="submit" class="btn btn-primary">Erstellen & Bearbeiten</button>
                        </div>
                    </form>`;
                this.showModal('formModal');
            },

            showExerciseSetForm() {
                let exerciseOptionsHTML = '';
                if (App.state.exercises.size > 0) {
                    exerciseOptionsHTML = Array.from(App.state.exercises.values()).map(ex => `
                        <div class="form-group" style="display: flex; align-items: center;">
                           <input type="checkbox" name="exerciseIds" value="${ex.id}" id="ex_sel_${ex.id}" style="width: auto; margin-right: 0.5rem;">
                           <label for="ex_sel_${ex.id}" style="margin-bottom:0;">${ex.name} (${ex.muscleGroup})</label>
                        </div>
                    `).join('');
                } else {
                    exerciseOptionsHTML = '<p>Bitte erstelle zuerst √úbungen, um sie einem Set hinzuzuf√ºgen.</p>';
                }

                document.getElementById('formModalContent').innerHTML = `
                    <h2>Neues √úbungsset erstellen</h2>
                    <form data-form="add-exercise-set">
                        <div class="form-group">
                            <label for="exercise-set-name">Name des Sets</label>
                            <input type="text" id="exercise-set-name" name="name" required>
                        </div>
                        <div class="form-group">
                            <h3>√úbungen ausw√§hlen:</h3>
                            <div style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border); padding: 1rem; border-radius: var(--radius);">
                                ${exerciseOptionsHTML}
                            </div>
                        </div>
                        <div style="display: flex; gap: 0.5rem; justify-content: flex-end; margin-top: 1rem;">
                            <button type="button" class="btn btn-secondary" data-action="close-modal" data-modal-id="formModal">Abbrechen</button>
                            <button type="submit" class="btn btn-primary" ${App.state.exercises.size === 0 ? 'disabled' : ''}>Set erstellen</button>
                        </div>
                    </form>`;
                this.showModal('formModal');
            },

            showEquipmentForm(equipmentDataToEdit = null) {
                const isEditMode = Boolean(equipmentDataToEdit);
                const currentId = isEditMode ? equipmentDataToEdit.id : '';
                const currentName = isEditMode ? equipmentDataToEdit.name : '';
                const currentDescription = isEditMode ? equipmentDataToEdit.description : '';

                const formHTML = `
                    <form data-form="equipment-form">
                        <h2>${isEditMode ? 'Ger√§t bearbeiten' : 'Neues Ger√§t erstellen'}</h2>
                        ${isEditMode ? `<input type="hidden" name="equipmentId" value="${currentId}">` : ''}
                        <div class="form-group">
                            <label for="eq-name">Name des Ger√§ts</label>
                            <input type="text" id="eq-name" name="name" value="${currentName}" required>
                        </div>
                        <div class="form-group">
                            <label for="eq-desc">Beschreibung (optional)</label>
                            <textarea id="eq-desc" name="description" rows="3">${currentDescription}</textarea>
                        </div>
                        <div style="display: flex; gap: 0.5rem; justify-content: flex-end; margin-top: 1rem;">
                            <button type="button" class="btn btn-secondary" data-action="close-modal" data-modal-id="formModal">Abbrechen</button>
                            <button type="submit" class="btn btn-primary">${isEditMode ? 'Ger√§t aktualisieren' : 'Ger√§t erstellen'}</button>
                        </div>
                    </form>
                `;
                document.getElementById('formModalContent').innerHTML = formHTML;
                this.showModal('formModal');
            },
            
            showPlanEditor(planId) {
                this.renderPlanEditorContent(planId);
                this.showModal('planEditorModal');
            },

            renderPlanEditorContent(planId) {
                const plan = App.state.plans.get(planId);
                if (!plan) {
                    document.getElementById('planEditorModalContent').innerHTML = '<h2>Fehler: Plan nicht gefunden.</h2><button class="btn" data-action="close-modal" data-modal-id="planEditorModal">Schlie√üen</button>';
                    return;
                }

                document.getElementById('planEditorModalContent').innerHTML = `
                    <div style="display:flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                        <h2 style="margin:0;">Plan: <input type="text" id="planEditorName" name="planName" value="${plan.name}" data-update-plan-meta data-plan-id="${planId}" style="font-size: 1.2em; border:none; border-bottom: 1px solid var(--border); background: transparent; color: var(--text-primary); width: auto; padding: 0.25rem;"></h2>
                        <button class="btn btn-primary" data-action="close-modal" data-modal-id="planEditorModal">Fertig & Schlie√üen</button>
                    </div>
                    <div class="form-group">
                        <label for="planEditorDescription" style="font-weight:500;">Beschreibung:</label>
                        <textarea id="planEditorDescription" name="planDescription" data-update-plan-meta data-plan-id="${planId}" rows="3" style="background: var(--surface-bg); color: var(--text-primary);">${plan.description || ''}</textarea>
                    </div>
                    <hr style="margin: 1.5rem 0;">
                    <div class="exercise-container" style="grid-template-columns: 1fr 2fr; gap: 2rem;">
                        <div class="exercise-list" style="max-height: 400px; overflow-y: auto; padding-right: 1rem; border-right: 1px solid var(--border);">
                            <h3>Verf√ºgbare √úbungen</h3>
                            ${Array.from(App.state.exercises.values()).map(ex => `<div class="exercise-item" draggable="true" data-drag-id="${ex.id}">${ex.name}</div>`).join('')}
                        </div>
                        <div class="drop-zone" data-drop-action="add-to-plan" data-plan-id="${plan.id}">
                            ${plan.exercises.map(ex => {
                                const exData = App.state.exercises.get(ex.id);
                                return `<div class="exercise-item" data-id="${ex.id}">
                                    <span>${exData.name}</span>
                                    <div style="display:flex; gap:0.5rem; align-items:center;">
                                        <input type="number" value="${ex.sets}" data-update-plan-ex data-plan-id="${plan.id}" data-ex-id="${ex.id}" data-field="sets" style="width: 60px;"> S
                                        <input type="text" value="${ex.reps}" data-update-plan-ex data-plan-id="${plan.id}" data-ex-id="${ex.id}" data-field="reps" style="width: 80px;"> Wdh
                                        <button class="btn btn-danger" style="padding:0.2rem 0.4rem" data-action="remove-exercise-from-plan" data-plan-id="${plan.id}" data-ex-id="${ex.id}">X</button>
                                    </div>
                                </div>`;
                            }).join('') || '<p>√úbungen hier ablegen</p>'}
                        </div>
                    </div>
                    <button class="btn btn-primary" style="margin-top:1rem" data-action="close-modal" data-modal-id="planEditorModal">Fertig</button>`;
            },

            showWorkoutCompleteModal(session) {
                const volume = App.logic.analytics.getWorkoutVolume(session);
                document.getElementById('workoutCompleteModalContent').innerHTML = `
                    <h2>üéâ Training Abgeschlossen!</h2>
                    <p>Starke Leistung! Hier ist deine Zusammenfassung:</p>
                    <p><strong>Dauer:</strong> ${((session.endTime - session.startTime)/60000).toFixed(0)} Min</p>
                    <p><strong>Gesamtvolumen:</strong> ${volume.toLocaleString()} kg</p>
                    <button class="btn btn-primary" data-action="close-modal" data-modal-id="workoutCompleteModal">Super!</button>`;
                this.showModal('workoutCompleteModal');
            },

            showModal(id) { document.getElementById(id).classList.add('active'); },
            closeModal(id) { 
                if (id === 'breathingModal') {
                    clearTimeout(App.timers.breath); // Clear the main cycle timer
                    App.timers.breath = null;
                    // If individual phase timeouts were stored, clear them too.
                    // For simplicity, this example assumes one main timer for the cycle sequence.
                }
                document.getElementById(id).classList.remove('active'); 
            },

            showToast(icon, message, type) {
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.innerHTML = `<span class="toast-icon">${icon}</span> <span>${message}</span>`;
                document.getElementById('notification-container').appendChild(toast);
                setTimeout(() => toast.remove(), 4000);
            },
            
            startRestTimer(durationSeconds) {
                const timerWidget = document.getElementById('restTimerWidget');
                const timerDisplay = document.getElementById('widgetTimer');

                if (!timerWidget || !timerDisplay) {
                    console.error("Rest timer UI elements not found.");
                    return;
                }

                clearInterval(App.timers.rest); // Clear any existing timer
                App.timers.rest = null;

                timerWidget.classList.add('active');
                let remainingSeconds = durationSeconds;

                const formatTime = s => `${String(Math.floor(s / 60)).padStart(2, '0')}:${String(s % 60).padStart(2, '0')}`;
                
                timerDisplay.textContent = formatTime(remainingSeconds);

                App.timers.rest = setInterval(() => {
                    remainingSeconds--;
                    timerDisplay.textContent = formatTime(remainingSeconds);
                    if (remainingSeconds <= 0) {
                        this.hideRestTimer(); // Calls clearInterval and hides widget
                        this.showToast("‚úÖ", "Pause beendet!", "success");
                        // Optional: Play a sound
                        // const audio = new Audio('path/to/sound.mp3');
                        // audio.play().catch(e => console.warn("Audio play failed:", e));
                    }
                }, 1000);
            },

            hideRestTimer() {
                clearInterval(App.timers.rest);
                App.timers.rest = null; // Ensure timer ID is cleared
                const timerWidget = document.getElementById('restTimerWidget');
                if (timerWidget) {
                    timerWidget.classList.remove('active');
                }
            },
            
            showBreathingGuide() {
                this.showModal('breathingModal');
                clearTimeout(App.timers.breath); // Clear any existing breath timer
                App.timers.breath = null;

                const circle = document.getElementById('breathing-circle');
                const text = document.getElementById('breathingText');
                if (!circle || !text) {
                    console.error("Breathing modal elements not found.");
                    return;
                }

                let currentCycle = 0;
                const maxCycles = 3;
                const inhaleTime = 4000;
                const holdAfterInhaleTime = 2000;
                const exhaleTime = 4000;
                const holdAfterExhaleTime = 2000;

                const sequence = [
                    { phase: "Einatmen...", duration: inhaleTime, scale: 1.2 },
                    { phase: "Halten...", duration: holdAfterInhaleTime, scale: 1.2 },
                    { phase: "Ausatmen...", duration: exhaleTime, scale: 1.0 },
                    { phase: "Halten...", duration: holdAfterExhaleTime, scale: 1.0 }
                ];
                
                let phaseIndex = 0;

                const performCycle = () => {
                    if (!document.getElementById('breathingModal').classList.contains('active') || currentCycle >= maxCycles) {
                        // Auto-close or enable button after cycles, or if modal closed manually
                        if (document.getElementById('breathingModal').classList.contains('active')) {
                           text.textContent = "Fertig!";
                           // Optionally, enable a 'Done' button if it was disabled
                        }
                        clearTimeout(App.timers.breath);
                        App.timers.breath = null;
                        return;
                    }

                    const currentPhase = sequence[phaseIndex];
                    text.textContent = currentPhase.phase;
                    circle.style.transform = `scale(${currentPhase.scale})`;

                    App.timers.breath = setTimeout(() => {
                        phaseIndex++;
                        if (phaseIndex >= sequence.length) {
                            phaseIndex = 0;
                            currentCycle++;
                        }
                        performCycle();
                    }, currentPhase.duration);
                };

                performCycle(); // Start the first cycle
            },
            
            createOrUpdateChart(id, type, data, options = {}) {
                const canvas = document.getElementById(id);
                if (!canvas) return;
                if (App.charts[id]) App.charts[id].destroy();
                App.charts[id] = new Chart(canvas.getContext('2d'), { type, data, options: {
                    responsive: true, maintainAspectRatio: false, ...options
                }});
            }
        }
    };
    
    // Start the application once the DOM is ready.
    document.addEventListener('DOMContentLoaded', () => App.init());
    
    </script>
</body>
</html>